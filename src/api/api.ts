/* tslint:disable */
/* eslint-disable */
/**
 * SpaceTraders API
 * SpaceTraders is an open-universe game and learning platform that offers a set of HTTP endpoints to control a fleet of ships and explore a multiplayer universe.  The API is documented using [OpenAPI](https://github.com/SpaceTradersAPI/api-docs). You can send your first request right here in your browser to check the status of the game server.  ```json http {   \"method\": \"GET\",   \"url\": \"https://api.spacetraders.io/v2\", } ```  Unlike a traditional game, SpaceTraders does not have a first-party client or app to play the game. Instead, you can use the API to build your own client, write a script to automate your ships, or try an app built by the community.  We have a [Discord channel](https://discord.com/invite/jh6zurdWk5) where you can share your projects, ask questions, and get help from other players.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: joel@spacetraders.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
import type { Configuration } from './configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base'
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setBearerAuthToObject,
  setSearchParams,
  toPathString,
} from './common'
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface AcceptContract200Response
 */
export interface AcceptContract200Response {
  /**
   *
   * @type {AcceptContract200ResponseData}
   * @memberof AcceptContract200Response
   */
  data: AcceptContract200ResponseData
}
/**
 *
 * @export
 * @interface AcceptContract200ResponseData
 */
export interface AcceptContract200ResponseData {
  /**
   *
   * @type {Agent}
   * @memberof AcceptContract200ResponseData
   */
  agent: Agent
  /**
   *
   * @type {Contract}
   * @memberof AcceptContract200ResponseData
   */
  contract: Contract
}
/**
 * The activity level of a trade good. If the good is an import, this represents how strong consumption is. If the good is an export, this represents how strong the production is for the good. When activity is strong, consumption or production is near maximum capacity. When activity is weak, consumption or production is near minimum capacity.
 * @export
 * @enum {string}
 */

export const ActivityLevel = {
  Weak: 'WEAK',
  Growing: 'GROWING',
  Strong: 'STRONG',
  Restricted: 'RESTRICTED',
} as const

export type ActivityLevel = (typeof ActivityLevel)[keyof typeof ActivityLevel]

/**
 * Agent details.
 * @export
 * @interface Agent
 */
export interface Agent {
  /**
   * Account ID that is tied to this agent. Only included on your own agent.
   * @type {string}
   * @memberof Agent
   */
  accountId?: string
  /**
   * Symbol of the agent.
   * @type {string}
   * @memberof Agent
   */
  symbol: string
  /**
   * The headquarters of the agent.
   * @type {string}
   * @memberof Agent
   */
  headquarters: string
  /**
   * The number of credits the agent has available. Credits can be negative if funds have been overdrawn.
   * @type {number}
   * @memberof Agent
   */
  credits: number
  /**
   * The faction the agent started with.
   * @type {string}
   * @memberof Agent
   */
  startingFaction: string
  /**
   * How many ships are owned by the agent.
   * @type {number}
   * @memberof Agent
   */
  shipCount: number
}
/**
 * The chart of a system or waypoint, which makes the location visible to other agents.
 * @export
 * @interface Chart
 */
export interface Chart {
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof Chart
   */
  waypointSymbol?: string
  /**
   * The agent that submitted the chart for this waypoint.
   * @type {string}
   * @memberof Chart
   */
  submittedBy?: string
  /**
   * The time the chart for this waypoint was submitted.
   * @type {string}
   * @memberof Chart
   */
  submittedOn?: string
}
/**
 * The construction details of a waypoint.
 * @export
 * @interface Construction
 */
export interface Construction {
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof Construction
   */
  symbol: string
  /**
   * The materials required to construct the waypoint.
   * @type {Array<ConstructionMaterial>}
   * @memberof Construction
   */
  materials: Array<ConstructionMaterial>
  /**
   * Whether the waypoint has been constructed.
   * @type {boolean}
   * @memberof Construction
   */
  isComplete: boolean
}
/**
 * The details of the required construction materials for a given waypoint under construction.
 * @export
 * @interface ConstructionMaterial
 */
export interface ConstructionMaterial {
  /**
   *
   * @type {TradeSymbol}
   * @memberof ConstructionMaterial
   */
  tradeSymbol: TradeSymbol
  /**
   * The number of units required.
   * @type {number}
   * @memberof ConstructionMaterial
   */
  required: number
  /**
   * The number of units fulfilled toward the required amount.
   * @type {number}
   * @memberof ConstructionMaterial
   */
  fulfilled: number
}

/**
 * Contract details.
 * @export
 * @interface Contract
 */
export interface Contract {
  /**
   * ID of the contract.
   * @type {string}
   * @memberof Contract
   */
  id: string
  /**
   * The symbol of the faction that this contract is for.
   * @type {string}
   * @memberof Contract
   */
  factionSymbol: string
  /**
   * Type of contract.
   * @type {string}
   * @memberof Contract
   */
  type: ContractTypeEnum
  /**
   *
   * @type {ContractTerms}
   * @memberof Contract
   */
  terms: ContractTerms
  /**
   * Whether the contract has been accepted by the agent
   * @type {boolean}
   * @memberof Contract
   */
  accepted: boolean
  /**
   * Whether the contract has been fulfilled
   * @type {boolean}
   * @memberof Contract
   */
  fulfilled: boolean
  /**
   * Deprecated in favor of deadlineToAccept
   * @type {string}
   * @memberof Contract
   * @deprecated
   */
  expiration: string
  /**
   * The time at which the contract is no longer available to be accepted
   * @type {string}
   * @memberof Contract
   */
  deadlineToAccept?: string
}

export const ContractTypeEnum = {
  Procurement: 'PROCUREMENT',
  Transport: 'TRANSPORT',
  Shuttle: 'SHUTTLE',
} as const

export type ContractTypeEnum = (typeof ContractTypeEnum)[keyof typeof ContractTypeEnum]

/**
 * The details of a delivery contract. Includes the type of good, units needed, and the destination.
 * @export
 * @interface ContractDeliverGood
 */
export interface ContractDeliverGood {
  /**
   * The symbol of the trade good to deliver.
   * @type {string}
   * @memberof ContractDeliverGood
   */
  tradeSymbol: string
  /**
   * The destination where goods need to be delivered.
   * @type {string}
   * @memberof ContractDeliverGood
   */
  destinationSymbol: string
  /**
   * The number of units that need to be delivered on this contract.
   * @type {number}
   * @memberof ContractDeliverGood
   */
  unitsRequired: number
  /**
   * The number of units fulfilled on this contract.
   * @type {number}
   * @memberof ContractDeliverGood
   */
  unitsFulfilled: number
}
/**
 * Payments for the contract.
 * @export
 * @interface ContractPayment
 */
export interface ContractPayment {
  /**
   * The amount of credits received up front for accepting the contract.
   * @type {number}
   * @memberof ContractPayment
   */
  onAccepted: number
  /**
   * The amount of credits received when the contract is fulfilled.
   * @type {number}
   * @memberof ContractPayment
   */
  onFulfilled: number
}
/**
 * The terms to fulfill the contract.
 * @export
 * @interface ContractTerms
 */
export interface ContractTerms {
  /**
   * The deadline for the contract.
   * @type {string}
   * @memberof ContractTerms
   */
  deadline: string
  /**
   *
   * @type {ContractPayment}
   * @memberof ContractTerms
   */
  payment: ContractPayment
  /**
   * The cargo that needs to be delivered to fulfill the contract.
   * @type {Array<ContractDeliverGood>}
   * @memberof ContractTerms
   */
  deliver?: Array<ContractDeliverGood>
}
/**
 * A cooldown is a period of time in which a ship cannot perform certain actions.
 * @export
 * @interface Cooldown
 */
export interface Cooldown {
  /**
   * The symbol of the ship that is on cooldown
   * @type {string}
   * @memberof Cooldown
   */
  shipSymbol: string
  /**
   * The total duration of the cooldown in seconds
   * @type {number}
   * @memberof Cooldown
   */
  totalSeconds: number
  /**
   * The remaining duration of the cooldown in seconds
   * @type {number}
   * @memberof Cooldown
   */
  remainingSeconds: number
  /**
   * The date and time when the cooldown expires in ISO 8601 format
   * @type {string}
   * @memberof Cooldown
   */
  expiration?: string
}
/**
 *
 * @export
 * @interface CreateChart201Response
 */
export interface CreateChart201Response {
  /**
   *
   * @type {CreateChart201ResponseData}
   * @memberof CreateChart201Response
   */
  data: CreateChart201ResponseData
}
/**
 *
 * @export
 * @interface CreateChart201ResponseData
 */
export interface CreateChart201ResponseData {
  /**
   *
   * @type {Chart}
   * @memberof CreateChart201ResponseData
   */
  chart: Chart
  /**
   *
   * @type {Waypoint}
   * @memberof CreateChart201ResponseData
   */
  waypoint: Waypoint
}
/**
 *
 * @export
 * @interface CreateShipShipScan201Response
 */
export interface CreateShipShipScan201Response {
  /**
   *
   * @type {CreateShipShipScan201ResponseData}
   * @memberof CreateShipShipScan201Response
   */
  data: CreateShipShipScan201ResponseData
}
/**
 *
 * @export
 * @interface CreateShipShipScan201ResponseData
 */
export interface CreateShipShipScan201ResponseData {
  /**
   *
   * @type {Cooldown}
   * @memberof CreateShipShipScan201ResponseData
   */
  cooldown: Cooldown
  /**
   * List of scanned ships.
   * @type {Array<ScannedShip>}
   * @memberof CreateShipShipScan201ResponseData
   */
  ships: Array<ScannedShip>
}
/**
 *
 * @export
 * @interface CreateShipSystemScan201Response
 */
export interface CreateShipSystemScan201Response {
  /**
   *
   * @type {CreateShipSystemScan201ResponseData}
   * @memberof CreateShipSystemScan201Response
   */
  data: CreateShipSystemScan201ResponseData
}
/**
 *
 * @export
 * @interface CreateShipSystemScan201ResponseData
 */
export interface CreateShipSystemScan201ResponseData {
  /**
   *
   * @type {Cooldown}
   * @memberof CreateShipSystemScan201ResponseData
   */
  cooldown: Cooldown
  /**
   * List of scanned systems.
   * @type {Array<ScannedSystem>}
   * @memberof CreateShipSystemScan201ResponseData
   */
  systems: Array<ScannedSystem>
}
/**
 *
 * @export
 * @interface CreateShipWaypointScan201Response
 */
export interface CreateShipWaypointScan201Response {
  /**
   *
   * @type {CreateShipWaypointScan201ResponseData}
   * @memberof CreateShipWaypointScan201Response
   */
  data: CreateShipWaypointScan201ResponseData
}
/**
 *
 * @export
 * @interface CreateShipWaypointScan201ResponseData
 */
export interface CreateShipWaypointScan201ResponseData {
  /**
   *
   * @type {Cooldown}
   * @memberof CreateShipWaypointScan201ResponseData
   */
  cooldown: Cooldown
  /**
   * List of scanned waypoints.
   * @type {Array<ScannedWaypoint>}
   * @memberof CreateShipWaypointScan201ResponseData
   */
  waypoints: Array<ScannedWaypoint>
}
/**
 *
 * @export
 * @interface CreateSurvey201Response
 */
export interface CreateSurvey201Response {
  /**
   *
   * @type {CreateSurvey201ResponseData}
   * @memberof CreateSurvey201Response
   */
  data: CreateSurvey201ResponseData
}
/**
 *
 * @export
 * @interface CreateSurvey201ResponseData
 */
export interface CreateSurvey201ResponseData {
  /**
   *
   * @type {Cooldown}
   * @memberof CreateSurvey201ResponseData
   */
  cooldown: Cooldown
  /**
   * Surveys created by this action.
   * @type {Array<Survey>}
   * @memberof CreateSurvey201ResponseData
   */
  surveys: Array<Survey>
}
/**
 *
 * @export
 * @interface DeliverContract200Response
 */
export interface DeliverContract200Response {
  /**
   *
   * @type {DeliverContract200ResponseData}
   * @memberof DeliverContract200Response
   */
  data: DeliverContract200ResponseData
}
/**
 *
 * @export
 * @interface DeliverContract200ResponseData
 */
export interface DeliverContract200ResponseData {
  /**
   *
   * @type {Contract}
   * @memberof DeliverContract200ResponseData
   */
  contract: Contract
  /**
   *
   * @type {ShipCargo}
   * @memberof DeliverContract200ResponseData
   */
  cargo: ShipCargo
}
/**
 *
 * @export
 * @interface DeliverContractRequest
 */
export interface DeliverContractRequest {
  /**
   * Symbol of a ship located in the destination to deliver a contract and that has a good to deliver in its cargo.
   * @type {string}
   * @memberof DeliverContractRequest
   */
  shipSymbol: string
  /**
   * The symbol of the good to deliver.
   * @type {string}
   * @memberof DeliverContractRequest
   */
  tradeSymbol: string
  /**
   * Amount of units to deliver.
   * @type {number}
   * @memberof DeliverContractRequest
   */
  units: number
}
/**
 *
 * @export
 * @interface DockShip200Response
 */
export interface DockShip200Response {
  /**
   *
   * @type {OrbitShip200ResponseData}
   * @memberof DockShip200Response
   */
  data: OrbitShip200ResponseData
}
/**
 *
 * @export
 * @interface ExtractResources201Response
 */
export interface ExtractResources201Response {
  /**
   *
   * @type {ExtractResources201ResponseData}
   * @memberof ExtractResources201Response
   */
  data: ExtractResources201ResponseData
}
/**
 *
 * @export
 * @interface ExtractResources201ResponseData
 */
export interface ExtractResources201ResponseData {
  /**
   *
   * @type {Cooldown}
   * @memberof ExtractResources201ResponseData
   */
  cooldown: Cooldown
  /**
   *
   * @type {Extraction}
   * @memberof ExtractResources201ResponseData
   */
  extraction: Extraction
  /**
   *
   * @type {ShipCargo}
   * @memberof ExtractResources201ResponseData
   */
  cargo: ShipCargo
}
/**
 *
 * @export
 * @interface ExtractResourcesRequest
 */
export interface ExtractResourcesRequest {
  /**
   *
   * @type {Survey}
   * @memberof ExtractResourcesRequest
   */
  survey?: Survey
}
/**
 * Extraction details.
 * @export
 * @interface Extraction
 */
export interface Extraction {
  /**
   * Symbol of the ship that executed the extraction.
   * @type {string}
   * @memberof Extraction
   */
  shipSymbol: string
  /**
   *
   * @type {ExtractionYield}
   * @memberof Extraction
   */
  yield: ExtractionYield
}
/**
 * A yield from the extraction operation.
 * @export
 * @interface ExtractionYield
 */
export interface ExtractionYield {
  /**
   *
   * @type {TradeSymbol}
   * @memberof ExtractionYield
   */
  symbol: TradeSymbol
  /**
   * The number of units extracted that were placed into the ship\'s cargo hold.
   * @type {number}
   * @memberof ExtractionYield
   */
  units: number
}

/**
 * Faction details.
 * @export
 * @interface Faction
 */
export interface Faction {
  /**
   *
   * @type {FactionSymbol}
   * @memberof Faction
   */
  symbol: FactionSymbol
  /**
   * Name of the faction.
   * @type {string}
   * @memberof Faction
   */
  name: string
  /**
   * Description of the faction.
   * @type {string}
   * @memberof Faction
   */
  description: string
  /**
   * The waypoint in which the faction\'s HQ is located in.
   * @type {string}
   * @memberof Faction
   */
  headquarters: string
  /**
   * List of traits that define this faction.
   * @type {Array<FactionTrait>}
   * @memberof Faction
   */
  traits: Array<FactionTrait>
  /**
   * Whether or not the faction is currently recruiting new agents.
   * @type {boolean}
   * @memberof Faction
   */
  isRecruiting: boolean
}

/**
 * The symbol of the faction.
 * @export
 * @enum {string}
 */

export const FactionSymbol = {
  Cosmic: 'COSMIC',
  Void: 'VOID',
  Galactic: 'GALACTIC',
  Quantum: 'QUANTUM',
  Dominion: 'DOMINION',
  Astro: 'ASTRO',
  Corsairs: 'CORSAIRS',
  Obsidian: 'OBSIDIAN',
  Aegis: 'AEGIS',
  United: 'UNITED',
  Solitary: 'SOLITARY',
  Cobalt: 'COBALT',
  Omega: 'OMEGA',
  Echo: 'ECHO',
  Lords: 'LORDS',
  Cult: 'CULT',
  Ancients: 'ANCIENTS',
  Shadow: 'SHADOW',
  Ethereal: 'ETHEREAL',
} as const

export type FactionSymbol = (typeof FactionSymbol)[keyof typeof FactionSymbol]

/**
 *
 * @export
 * @interface FactionTrait
 */
export interface FactionTrait {
  /**
   *
   * @type {FactionTraitSymbol}
   * @memberof FactionTrait
   */
  symbol: FactionTraitSymbol
  /**
   * The name of the trait.
   * @type {string}
   * @memberof FactionTrait
   */
  name: string
  /**
   * A description of the trait.
   * @type {string}
   * @memberof FactionTrait
   */
  description: string
}

/**
 * The unique identifier of the trait.
 * @export
 * @enum {string}
 */

export const FactionTraitSymbol = {
  Bureaucratic: 'BUREAUCRATIC',
  Secretive: 'SECRETIVE',
  Capitalistic: 'CAPITALISTIC',
  Industrious: 'INDUSTRIOUS',
  Peaceful: 'PEACEFUL',
  Distrustful: 'DISTRUSTFUL',
  Welcoming: 'WELCOMING',
  Smugglers: 'SMUGGLERS',
  Scavengers: 'SCAVENGERS',
  Rebellious: 'REBELLIOUS',
  Exiles: 'EXILES',
  Pirates: 'PIRATES',
  Raiders: 'RAIDERS',
  Clan: 'CLAN',
  Guild: 'GUILD',
  Dominion: 'DOMINION',
  Fringe: 'FRINGE',
  Forsaken: 'FORSAKEN',
  Isolated: 'ISOLATED',
  Localized: 'LOCALIZED',
  Established: 'ESTABLISHED',
  Notable: 'NOTABLE',
  Dominant: 'DOMINANT',
  Inescapable: 'INESCAPABLE',
  Innovative: 'INNOVATIVE',
  Bold: 'BOLD',
  Visionary: 'VISIONARY',
  Curious: 'CURIOUS',
  Daring: 'DARING',
  Exploratory: 'EXPLORATORY',
  Resourceful: 'RESOURCEFUL',
  Flexible: 'FLEXIBLE',
  Cooperative: 'COOPERATIVE',
  United: 'UNITED',
  Strategic: 'STRATEGIC',
  Intelligent: 'INTELLIGENT',
  ResearchFocused: 'RESEARCH_FOCUSED',
  Collaborative: 'COLLABORATIVE',
  Progressive: 'PROGRESSIVE',
  Militaristic: 'MILITARISTIC',
  TechnologicallyAdvanced: 'TECHNOLOGICALLY_ADVANCED',
  Aggressive: 'AGGRESSIVE',
  Imperialistic: 'IMPERIALISTIC',
  TreasureHunters: 'TREASURE_HUNTERS',
  Dexterous: 'DEXTEROUS',
  Unpredictable: 'UNPREDICTABLE',
  Brutal: 'BRUTAL',
  Fleeting: 'FLEETING',
  Adaptable: 'ADAPTABLE',
  SelfSufficient: 'SELF_SUFFICIENT',
  Defensive: 'DEFENSIVE',
  Proud: 'PROUD',
  Diverse: 'DIVERSE',
  Independent: 'INDEPENDENT',
  SelfInterested: 'SELF_INTERESTED',
  Fragmented: 'FRAGMENTED',
  Commercial: 'COMMERCIAL',
  FreeMarkets: 'FREE_MARKETS',
  Entrepreneurial: 'ENTREPRENEURIAL',
} as const

export type FactionTraitSymbol = (typeof FactionTraitSymbol)[keyof typeof FactionTraitSymbol]

/**
 *
 * @export
 * @interface FulfillContract200Response
 */
export interface FulfillContract200Response {
  /**
   *
   * @type {AcceptContract200ResponseData}
   * @memberof FulfillContract200Response
   */
  data: AcceptContract200ResponseData
}
/**
 *
 * @export
 * @interface GetAgents200Response
 */
export interface GetAgents200Response {
  /**
   *
   * @type {Array<Agent>}
   * @memberof GetAgents200Response
   */
  data: Array<Agent>
  /**
   *
   * @type {Meta}
   * @memberof GetAgents200Response
   */
  meta: Meta
}
/**
 *
 * @export
 * @interface GetConstruction200Response
 */
export interface GetConstruction200Response {
  /**
   *
   * @type {Construction}
   * @memberof GetConstruction200Response
   */
  data: Construction
}
/**
 *
 * @export
 * @interface GetContract200Response
 */
export interface GetContract200Response {
  /**
   *
   * @type {Contract}
   * @memberof GetContract200Response
   */
  data: Contract
}
/**
 *
 * @export
 * @interface GetContracts200Response
 */
export interface GetContracts200Response {
  /**
   *
   * @type {Array<Contract>}
   * @memberof GetContracts200Response
   */
  data: Array<Contract>
  /**
   *
   * @type {Meta}
   * @memberof GetContracts200Response
   */
  meta: Meta
}
/**
 *
 * @export
 * @interface GetFaction200Response
 */
export interface GetFaction200Response {
  /**
   *
   * @type {Faction}
   * @memberof GetFaction200Response
   */
  data: Faction
}
/**
 *
 * @export
 * @interface GetFactions200Response
 */
export interface GetFactions200Response {
  /**
   *
   * @type {Array<Faction>}
   * @memberof GetFactions200Response
   */
  data: Array<Faction>
  /**
   *
   * @type {Meta}
   * @memberof GetFactions200Response
   */
  meta: Meta
}
/**
 *
 * @export
 * @interface GetJumpGate200Response
 */
export interface GetJumpGate200Response {
  /**
   *
   * @type {JumpGate}
   * @memberof GetJumpGate200Response
   */
  data: JumpGate
}
/**
 *
 * @export
 * @interface GetMarket200Response
 */
export interface GetMarket200Response {
  /**
   *
   * @type {Market}
   * @memberof GetMarket200Response
   */
  data: Market
}
/**
 *
 * @export
 * @interface GetMounts200Response
 */
export interface GetMounts200Response {
  /**
   *
   * @type {Array<ShipMount>}
   * @memberof GetMounts200Response
   */
  data: Array<ShipMount>
}
/**
 *
 * @export
 * @interface GetMyAgent200Response
 */
export interface GetMyAgent200Response {
  /**
   *
   * @type {Agent}
   * @memberof GetMyAgent200Response
   */
  data: Agent
}
/**
 *
 * @export
 * @interface GetMyShip200Response
 */
export interface GetMyShip200Response {
  /**
   *
   * @type {Ship}
   * @memberof GetMyShip200Response
   */
  data: Ship
}
/**
 *
 * @export
 * @interface GetMyShipCargo200Response
 */
export interface GetMyShipCargo200Response {
  /**
   *
   * @type {ShipCargo}
   * @memberof GetMyShipCargo200Response
   */
  data: ShipCargo
}
/**
 *
 * @export
 * @interface GetMyShips200Response
 */
export interface GetMyShips200Response {
  /**
   *
   * @type {Array<Ship>}
   * @memberof GetMyShips200Response
   */
  data: Array<Ship>
  /**
   *
   * @type {Meta}
   * @memberof GetMyShips200Response
   */
  meta: Meta
}
/**
 *
 * @export
 * @interface GetShipCooldown200Response
 */
export interface GetShipCooldown200Response {
  /**
   *
   * @type {Cooldown}
   * @memberof GetShipCooldown200Response
   */
  data: Cooldown
}
/**
 *
 * @export
 * @interface GetShipNav200Response
 */
export interface GetShipNav200Response {
  /**
   *
   * @type {ShipNav}
   * @memberof GetShipNav200Response
   */
  data: ShipNav
}
/**
 *
 * @export
 * @interface GetShipyard200Response
 */
export interface GetShipyard200Response {
  /**
   *
   * @type {Shipyard}
   * @memberof GetShipyard200Response
   */
  data: Shipyard
}
/**
 *
 * @export
 * @interface GetStatus200Response
 */
export interface GetStatus200Response {
  /**
   * The current status of the game server.
   * @type {string}
   * @memberof GetStatus200Response
   */
  status: string
  /**
   * The current version of the API.
   * @type {string}
   * @memberof GetStatus200Response
   */
  version: string
  /**
   * The date when the game server was last reset.
   * @type {string}
   * @memberof GetStatus200Response
   */
  resetDate: string
  /**
   *
   * @type {string}
   * @memberof GetStatus200Response
   */
  description: string
  /**
   *
   * @type {GetStatus200ResponseStats}
   * @memberof GetStatus200Response
   */
  stats: GetStatus200ResponseStats
  /**
   *
   * @type {GetStatus200ResponseLeaderboards}
   * @memberof GetStatus200Response
   */
  leaderboards: GetStatus200ResponseLeaderboards
  /**
   *
   * @type {GetStatus200ResponseServerResets}
   * @memberof GetStatus200Response
   */
  serverResets: GetStatus200ResponseServerResets
  /**
   *
   * @type {Array<GetStatus200ResponseAnnouncementsInner>}
   * @memberof GetStatus200Response
   */
  announcements: Array<GetStatus200ResponseAnnouncementsInner>
  /**
   *
   * @type {Array<GetStatus200ResponseLinksInner>}
   * @memberof GetStatus200Response
   */
  links: Array<GetStatus200ResponseLinksInner>
}
/**
 *
 * @export
 * @interface GetStatus200ResponseAnnouncementsInner
 */
export interface GetStatus200ResponseAnnouncementsInner {
  /**
   *
   * @type {string}
   * @memberof GetStatus200ResponseAnnouncementsInner
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof GetStatus200ResponseAnnouncementsInner
   */
  body: string
}
/**
 *
 * @export
 * @interface GetStatus200ResponseLeaderboards
 */
export interface GetStatus200ResponseLeaderboards {
  /**
   * Top agents with the most credits.
   * @type {Array<GetStatus200ResponseLeaderboardsMostCreditsInner>}
   * @memberof GetStatus200ResponseLeaderboards
   */
  mostCredits: Array<GetStatus200ResponseLeaderboardsMostCreditsInner>
  /**
   * Top agents with the most charted submitted.
   * @type {Array<GetStatus200ResponseLeaderboardsMostSubmittedChartsInner>}
   * @memberof GetStatus200ResponseLeaderboards
   */
  mostSubmittedCharts: Array<GetStatus200ResponseLeaderboardsMostSubmittedChartsInner>
}
/**
 *
 * @export
 * @interface GetStatus200ResponseLeaderboardsMostCreditsInner
 */
export interface GetStatus200ResponseLeaderboardsMostCreditsInner {
  /**
   * Symbol of the agent.
   * @type {string}
   * @memberof GetStatus200ResponseLeaderboardsMostCreditsInner
   */
  agentSymbol: string
  /**
   * Amount of credits.
   * @type {number}
   * @memberof GetStatus200ResponseLeaderboardsMostCreditsInner
   */
  credits: number
}
/**
 *
 * @export
 * @interface GetStatus200ResponseLeaderboardsMostSubmittedChartsInner
 */
export interface GetStatus200ResponseLeaderboardsMostSubmittedChartsInner {
  /**
   * Symbol of the agent.
   * @type {string}
   * @memberof GetStatus200ResponseLeaderboardsMostSubmittedChartsInner
   */
  agentSymbol: string
  /**
   * Amount of charts done by the agent.
   * @type {number}
   * @memberof GetStatus200ResponseLeaderboardsMostSubmittedChartsInner
   */
  chartCount: number
}
/**
 *
 * @export
 * @interface GetStatus200ResponseLinksInner
 */
export interface GetStatus200ResponseLinksInner {
  /**
   *
   * @type {string}
   * @memberof GetStatus200ResponseLinksInner
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof GetStatus200ResponseLinksInner
   */
  url: string
}
/**
 *
 * @export
 * @interface GetStatus200ResponseServerResets
 */
export interface GetStatus200ResponseServerResets {
  /**
   * The date and time when the game server will reset.
   * @type {string}
   * @memberof GetStatus200ResponseServerResets
   */
  next: string
  /**
   * How often we intend to reset the game server.
   * @type {string}
   * @memberof GetStatus200ResponseServerResets
   */
  frequency: string
}
/**
 *
 * @export
 * @interface GetStatus200ResponseStats
 */
export interface GetStatus200ResponseStats {
  /**
   * Number of registered agents in the game.
   * @type {number}
   * @memberof GetStatus200ResponseStats
   */
  agents: number
  /**
   * Total number of ships in the game.
   * @type {number}
   * @memberof GetStatus200ResponseStats
   */
  ships: number
  /**
   * Total number of systems in the game.
   * @type {number}
   * @memberof GetStatus200ResponseStats
   */
  systems: number
  /**
   * Total number of waypoints in the game.
   * @type {number}
   * @memberof GetStatus200ResponseStats
   */
  waypoints: number
}
/**
 *
 * @export
 * @interface GetSystem200Response
 */
export interface GetSystem200Response {
  /**
   *
   * @type {System}
   * @memberof GetSystem200Response
   */
  data: System
}
/**
 *
 * @export
 * @interface GetSystemWaypoints200Response
 */
export interface GetSystemWaypoints200Response {
  /**
   *
   * @type {Array<Waypoint>}
   * @memberof GetSystemWaypoints200Response
   */
  data: Array<Waypoint>
  /**
   *
   * @type {Meta}
   * @memberof GetSystemWaypoints200Response
   */
  meta: Meta
}
/**
 * @type GetSystemWaypointsTraitsParameter
 * @export
 */
export type GetSystemWaypointsTraitsParameter = Array<WaypointTraitSymbol> | WaypointTraitSymbol

/**
 *
 * @export
 * @interface GetSystems200Response
 */
export interface GetSystems200Response {
  /**
   *
   * @type {Array<System>}
   * @memberof GetSystems200Response
   */
  data: Array<System>
  /**
   *
   * @type {Meta}
   * @memberof GetSystems200Response
   */
  meta: Meta
}
/**
 *
 * @export
 * @interface GetWaypoint200Response
 */
export interface GetWaypoint200Response {
  /**
   *
   * @type {Waypoint}
   * @memberof GetWaypoint200Response
   */
  data: Waypoint
}
/**
 *
 * @export
 * @interface InstallMount201Response
 */
export interface InstallMount201Response {
  /**
   *
   * @type {InstallMount201ResponseData}
   * @memberof InstallMount201Response
   */
  data: InstallMount201ResponseData
}
/**
 *
 * @export
 * @interface InstallMount201ResponseData
 */
export interface InstallMount201ResponseData {
  /**
   *
   * @type {Agent}
   * @memberof InstallMount201ResponseData
   */
  agent: Agent
  /**
   * List of installed mounts after the installation of the new mount.
   * @type {Array<ShipMount>}
   * @memberof InstallMount201ResponseData
   */
  mounts: Array<ShipMount>
  /**
   *
   * @type {ShipCargo}
   * @memberof InstallMount201ResponseData
   */
  cargo: ShipCargo
  /**
   *
   * @type {ShipModificationTransaction}
   * @memberof InstallMount201ResponseData
   */
  transaction: ShipModificationTransaction
}
/**
 *
 * @export
 * @interface InstallMountRequest
 */
export interface InstallMountRequest {
  /**
   *
   * @type {string}
   * @memberof InstallMountRequest
   */
  symbol: string
}
/**
 *
 * @export
 * @interface Jettison200Response
 */
export interface Jettison200Response {
  /**
   *
   * @type {Jettison200ResponseData}
   * @memberof Jettison200Response
   */
  data: Jettison200ResponseData
}
/**
 *
 * @export
 * @interface Jettison200ResponseData
 */
export interface Jettison200ResponseData {
  /**
   *
   * @type {ShipCargo}
   * @memberof Jettison200ResponseData
   */
  cargo: ShipCargo
}
/**
 *
 * @export
 * @interface JettisonRequest
 */
export interface JettisonRequest {
  /**
   *
   * @type {TradeSymbol}
   * @memberof JettisonRequest
   */
  symbol: TradeSymbol
  /**
   * Amount of units to jettison of this good.
   * @type {number}
   * @memberof JettisonRequest
   */
  units: number
}

/**
 *
 * @export
 * @interface JumpGate
 */
export interface JumpGate {
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof JumpGate
   */
  symbol: string
  /**
   * All the gates that are connected to this waypoint.
   * @type {Array<string>}
   * @memberof JumpGate
   */
  connections: Array<string>
}
/**
 *
 * @export
 * @interface JumpShip200Response
 */
export interface JumpShip200Response {
  /**
   *
   * @type {JumpShip200ResponseData}
   * @memberof JumpShip200Response
   */
  data: JumpShip200ResponseData
}
/**
 *
 * @export
 * @interface JumpShip200ResponseData
 */
export interface JumpShip200ResponseData {
  /**
   *
   * @type {ShipNav}
   * @memberof JumpShip200ResponseData
   */
  nav: ShipNav
  /**
   *
   * @type {Cooldown}
   * @memberof JumpShip200ResponseData
   */
  cooldown: Cooldown
  /**
   *
   * @type {MarketTransaction}
   * @memberof JumpShip200ResponseData
   */
  transaction: MarketTransaction
  /**
   *
   * @type {Agent}
   * @memberof JumpShip200ResponseData
   */
  agent: Agent
}
/**
 *
 * @export
 * @interface JumpShipRequest
 */
export interface JumpShipRequest {
  /**
   * The symbol of the waypoint to jump to. The destination must be a connected waypoint.
   * @type {string}
   * @memberof JumpShipRequest
   */
  waypointSymbol: string
}
/**
 *
 * @export
 * @interface Market
 */
export interface Market {
  /**
   * The symbol of the market. The symbol is the same as the waypoint where the market is located.
   * @type {string}
   * @memberof Market
   */
  symbol: string
  /**
   * The list of goods that are exported from this market.
   * @type {Array<TradeGood>}
   * @memberof Market
   */
  exports: Array<TradeGood>
  /**
   * The list of goods that are sought as imports in this market.
   * @type {Array<TradeGood>}
   * @memberof Market
   */
  imports: Array<TradeGood>
  /**
   * The list of goods that are bought and sold between agents at this market.
   * @type {Array<TradeGood>}
   * @memberof Market
   */
  exchange: Array<TradeGood>
  /**
   * The list of recent transactions at this market. Visible only when a ship is present at the market.
   * @type {Array<MarketTransaction>}
   * @memberof Market
   */
  transactions?: Array<MarketTransaction>
  /**
   * The list of goods that are traded at this market. Visible only when a ship is present at the market.
   * @type {Array<MarketTradeGood>}
   * @memberof Market
   */
  tradeGoods?: Array<MarketTradeGood>
}
/**
 *
 * @export
 * @interface MarketTradeGood
 */
export interface MarketTradeGood {
  /**
   *
   * @type {TradeSymbol}
   * @memberof MarketTradeGood
   */
  symbol: TradeSymbol
  /**
   * The type of trade good (export, import, or exchange).
   * @type {string}
   * @memberof MarketTradeGood
   */
  type: MarketTradeGoodTypeEnum
  /**
   * This is the maximum number of units that can be purchased or sold at this market in a single trade for this good. Trade volume also gives an indication of price volatility. A market with a low trade volume will have large price swings, while high trade volume will be more resilient to price changes.
   * @type {number}
   * @memberof MarketTradeGood
   */
  tradeVolume: number
  /**
   *
   * @type {SupplyLevel}
   * @memberof MarketTradeGood
   */
  supply: SupplyLevel
  /**
   *
   * @type {ActivityLevel}
   * @memberof MarketTradeGood
   */
  activity?: ActivityLevel
  /**
   * The price at which this good can be purchased from the market.
   * @type {number}
   * @memberof MarketTradeGood
   */
  purchasePrice: number
  /**
   * The price at which this good can be sold to the market.
   * @type {number}
   * @memberof MarketTradeGood
   */
  sellPrice: number
}

export const MarketTradeGoodTypeEnum = {
  Export: 'EXPORT',
  Import: 'IMPORT',
  Exchange: 'EXCHANGE',
} as const

export type MarketTradeGoodTypeEnum = (typeof MarketTradeGoodTypeEnum)[keyof typeof MarketTradeGoodTypeEnum]

/**
 * Result of a transaction with a market.
 * @export
 * @interface MarketTransaction
 */
export interface MarketTransaction {
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof MarketTransaction
   */
  waypointSymbol: string
  /**
   * The symbol of the ship that made the transaction.
   * @type {string}
   * @memberof MarketTransaction
   */
  shipSymbol: string
  /**
   * The symbol of the trade good.
   * @type {string}
   * @memberof MarketTransaction
   */
  tradeSymbol: string
  /**
   * The type of transaction.
   * @type {string}
   * @memberof MarketTransaction
   */
  type: MarketTransactionTypeEnum
  /**
   * The number of units of the transaction.
   * @type {number}
   * @memberof MarketTransaction
   */
  units: number
  /**
   * The price per unit of the transaction.
   * @type {number}
   * @memberof MarketTransaction
   */
  pricePerUnit: number
  /**
   * The total price of the transaction.
   * @type {number}
   * @memberof MarketTransaction
   */
  totalPrice: number
  /**
   * The timestamp of the transaction.
   * @type {string}
   * @memberof MarketTransaction
   */
  timestamp: string
}

export const MarketTransactionTypeEnum = {
  Purchase: 'PURCHASE',
  Sell: 'SELL',
} as const

export type MarketTransactionTypeEnum = (typeof MarketTransactionTypeEnum)[keyof typeof MarketTransactionTypeEnum]

/**
 * Meta details for pagination.
 * @export
 * @interface Meta
 */
export interface Meta {
  /**
   * Shows the total amount of items of this kind that exist.
   * @type {number}
   * @memberof Meta
   */
  total: number
  /**
   * A page denotes an amount of items, offset from the first item. Each page holds an amount of items equal to the `limit`.
   * @type {number}
   * @memberof Meta
   */
  page: number
  /**
   * The amount of items in each page. Limits how many items can be fetched at once.
   * @type {number}
   * @memberof Meta
   */
  limit: number
}
/**
 *
 * @export
 * @interface NavigateShip200Response
 */
export interface NavigateShip200Response {
  /**
   *
   * @type {NavigateShip200ResponseData}
   * @memberof NavigateShip200Response
   */
  data: NavigateShip200ResponseData
}
/**
 *
 * @export
 * @interface NavigateShip200ResponseData
 */
export interface NavigateShip200ResponseData {
  /**
   *
   * @type {ShipFuel}
   * @memberof NavigateShip200ResponseData
   */
  fuel: ShipFuel
  /**
   *
   * @type {ShipNav}
   * @memberof NavigateShip200ResponseData
   */
  nav: ShipNav
}
/**
 *
 * @export
 * @interface NavigateShipRequest
 */
export interface NavigateShipRequest {
  /**
   * The target destination.
   * @type {string}
   * @memberof NavigateShipRequest
   */
  waypointSymbol: string
}
/**
 *
 * @export
 * @interface NegotiateContract200Response
 */
export interface NegotiateContract200Response {
  /**
   *
   * @type {NegotiateContract200ResponseData}
   * @memberof NegotiateContract200Response
   */
  data: NegotiateContract200ResponseData
}
/**
 *
 * @export
 * @interface NegotiateContract200ResponseData
 */
export interface NegotiateContract200ResponseData {
  /**
   *
   * @type {Contract}
   * @memberof NegotiateContract200ResponseData
   */
  contract: Contract
}
/**
 *
 * @export
 * @interface OrbitShip200Response
 */
export interface OrbitShip200Response {
  /**
   *
   * @type {OrbitShip200ResponseData}
   * @memberof OrbitShip200Response
   */
  data: OrbitShip200ResponseData
}
/**
 *
 * @export
 * @interface OrbitShip200ResponseData
 */
export interface OrbitShip200ResponseData {
  /**
   *
   * @type {ShipNav}
   * @memberof OrbitShip200ResponseData
   */
  nav: ShipNav
}
/**
 *
 * @export
 * @interface PatchShipNavRequest
 */
export interface PatchShipNavRequest {
  /**
   *
   * @type {ShipNavFlightMode}
   * @memberof PatchShipNavRequest
   */
  flightMode?: ShipNavFlightMode
}

/**
 *
 * @export
 * @interface PurchaseCargo201Response
 */
export interface PurchaseCargo201Response {
  /**
   *
   * @type {SellCargo201ResponseData}
   * @memberof PurchaseCargo201Response
   */
  data: SellCargo201ResponseData
}
/**
 *
 * @export
 * @interface PurchaseCargoRequest
 */
export interface PurchaseCargoRequest {
  /**
   *
   * @type {TradeSymbol}
   * @memberof PurchaseCargoRequest
   */
  symbol: TradeSymbol
  /**
   * Amounts of units to purchase.
   * @type {number}
   * @memberof PurchaseCargoRequest
   */
  units: number
}

/**
 *
 * @export
 * @interface PurchaseShip201Response
 */
export interface PurchaseShip201Response {
  /**
   *
   * @type {PurchaseShip201ResponseData}
   * @memberof PurchaseShip201Response
   */
  data: PurchaseShip201ResponseData
}
/**
 *
 * @export
 * @interface PurchaseShip201ResponseData
 */
export interface PurchaseShip201ResponseData {
  /**
   *
   * @type {Agent}
   * @memberof PurchaseShip201ResponseData
   */
  agent: Agent
  /**
   *
   * @type {Ship}
   * @memberof PurchaseShip201ResponseData
   */
  ship: Ship
  /**
   *
   * @type {ShipyardTransaction}
   * @memberof PurchaseShip201ResponseData
   */
  transaction: ShipyardTransaction
}
/**
 *
 * @export
 * @interface PurchaseShipRequest
 */
export interface PurchaseShipRequest {
  /**
   *
   * @type {ShipType}
   * @memberof PurchaseShipRequest
   */
  shipType: ShipType
  /**
   * The symbol of the waypoint you want to purchase the ship at.
   * @type {string}
   * @memberof PurchaseShipRequest
   */
  waypointSymbol: string
}

/**
 *
 * @export
 * @interface RefuelShip200Response
 */
export interface RefuelShip200Response {
  /**
   *
   * @type {RefuelShip200ResponseData}
   * @memberof RefuelShip200Response
   */
  data: RefuelShip200ResponseData
}
/**
 *
 * @export
 * @interface RefuelShip200ResponseData
 */
export interface RefuelShip200ResponseData {
  /**
   *
   * @type {Agent}
   * @memberof RefuelShip200ResponseData
   */
  agent: Agent
  /**
   *
   * @type {ShipFuel}
   * @memberof RefuelShip200ResponseData
   */
  fuel: ShipFuel
  /**
   *
   * @type {MarketTransaction}
   * @memberof RefuelShip200ResponseData
   */
  transaction: MarketTransaction
}
/**
 *
 * @export
 * @interface RefuelShipRequest
 */
export interface RefuelShipRequest {
  /**
   * The amount of fuel to fill in the ship\'s tanks. When not specified, the ship will be refueled to its maximum fuel capacity. If the amount specified is greater than the ship\'s remaining capacity, the ship will only be refueled to its maximum fuel capacity. The amount specified is not in market units but in ship fuel units.
   * @type {number}
   * @memberof RefuelShipRequest
   */
  units?: number
  /**
   * Wether to use the FUEL thats in your cargo or not. Default: false
   * @type {boolean}
   * @memberof RefuelShipRequest
   */
  fromCargo?: boolean
}
/**
 *
 * @export
 * @interface Register201Response
 */
export interface Register201Response {
  /**
   *
   * @type {Register201ResponseData}
   * @memberof Register201Response
   */
  data: Register201ResponseData
}
/**
 *
 * @export
 * @interface Register201ResponseData
 */
export interface Register201ResponseData {
  /**
   *
   * @type {Agent}
   * @memberof Register201ResponseData
   */
  agent: Agent
  /**
   *
   * @type {Contract}
   * @memberof Register201ResponseData
   */
  contract: Contract
  /**
   *
   * @type {Faction}
   * @memberof Register201ResponseData
   */
  faction: Faction
  /**
   *
   * @type {Ship}
   * @memberof Register201ResponseData
   */
  ship: Ship
  /**
   * A Bearer token for accessing secured API endpoints.
   * @type {string}
   * @memberof Register201ResponseData
   */
  token: string
}
/**
 *
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
  /**
   *
   * @type {FactionSymbol}
   * @memberof RegisterRequest
   */
  faction: FactionSymbol
  /**
   * Your desired agent symbol. This will be a unique name used to represent your agent, and will be the prefix for your ships.
   * @type {string}
   * @memberof RegisterRequest
   */
  symbol: string
  /**
   * Your email address. This is used if you reserved your call sign between resets.
   * @type {string}
   * @memberof RegisterRequest
   */
  email?: string
}

/**
 *
 * @export
 * @interface RemoveMount201Response
 */
export interface RemoveMount201Response {
  /**
   *
   * @type {RemoveMount201ResponseData}
   * @memberof RemoveMount201Response
   */
  data: RemoveMount201ResponseData
}
/**
 *
 * @export
 * @interface RemoveMount201ResponseData
 */
export interface RemoveMount201ResponseData {
  /**
   *
   * @type {Agent}
   * @memberof RemoveMount201ResponseData
   */
  agent: Agent
  /**
   * List of installed mounts after the removal of the selected mount.
   * @type {Array<ShipMount>}
   * @memberof RemoveMount201ResponseData
   */
  mounts: Array<ShipMount>
  /**
   *
   * @type {ShipCargo}
   * @memberof RemoveMount201ResponseData
   */
  cargo: ShipCargo
  /**
   *
   * @type {ShipModificationTransaction}
   * @memberof RemoveMount201ResponseData
   */
  transaction: ShipModificationTransaction
}
/**
 *
 * @export
 * @interface RemoveMountRequest
 */
export interface RemoveMountRequest {
  /**
   * The symbol of the mount to remove.
   * @type {string}
   * @memberof RemoveMountRequest
   */
  symbol: string
}
/**
 * The ship that was scanned. Details include information about the ship that could be detected by the scanner.
 * @export
 * @interface ScannedShip
 */
export interface ScannedShip {
  /**
   * The globally unique identifier of the ship.
   * @type {string}
   * @memberof ScannedShip
   */
  symbol: string
  /**
   *
   * @type {ShipRegistration}
   * @memberof ScannedShip
   */
  registration: ShipRegistration
  /**
   *
   * @type {ShipNav}
   * @memberof ScannedShip
   */
  nav: ShipNav
  /**
   *
   * @type {ScannedShipFrame}
   * @memberof ScannedShip
   */
  frame?: ScannedShipFrame
  /**
   *
   * @type {ScannedShipReactor}
   * @memberof ScannedShip
   */
  reactor?: ScannedShipReactor
  /**
   *
   * @type {ScannedShipEngine}
   * @memberof ScannedShip
   */
  engine: ScannedShipEngine
  /**
   * List of mounts installed in the ship.
   * @type {Array<ScannedShipMountsInner>}
   * @memberof ScannedShip
   */
  mounts?: Array<ScannedShipMountsInner>
}
/**
 * The engine of the ship.
 * @export
 * @interface ScannedShipEngine
 */
export interface ScannedShipEngine {
  /**
   * The symbol of the engine.
   * @type {string}
   * @memberof ScannedShipEngine
   */
  symbol: string
}
/**
 * The frame of the ship.
 * @export
 * @interface ScannedShipFrame
 */
export interface ScannedShipFrame {
  /**
   * The symbol of the frame.
   * @type {string}
   * @memberof ScannedShipFrame
   */
  symbol: string
}
/**
 * A mount on the ship.
 * @export
 * @interface ScannedShipMountsInner
 */
export interface ScannedShipMountsInner {
  /**
   * The symbol of the mount.
   * @type {string}
   * @memberof ScannedShipMountsInner
   */
  symbol: string
}
/**
 * The reactor of the ship.
 * @export
 * @interface ScannedShipReactor
 */
export interface ScannedShipReactor {
  /**
   * The symbol of the reactor.
   * @type {string}
   * @memberof ScannedShipReactor
   */
  symbol: string
}
/**
 * Details of a system was that scanned.
 * @export
 * @interface ScannedSystem
 */
export interface ScannedSystem {
  /**
   * Symbol of the system.
   * @type {string}
   * @memberof ScannedSystem
   */
  symbol: string
  /**
   * Symbol of the system\'s sector.
   * @type {string}
   * @memberof ScannedSystem
   */
  sectorSymbol: string
  /**
   *
   * @type {SystemType}
   * @memberof ScannedSystem
   */
  type: SystemType
  /**
   * Position in the universe in the x axis.
   * @type {number}
   * @memberof ScannedSystem
   */
  x: number
  /**
   * Position in the universe in the y axis.
   * @type {number}
   * @memberof ScannedSystem
   */
  y: number
  /**
   * The system\'s distance from the scanning ship.
   * @type {number}
   * @memberof ScannedSystem
   */
  distance: number
}

/**
 * A waypoint that was scanned by a ship.
 * @export
 * @interface ScannedWaypoint
 */
export interface ScannedWaypoint {
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof ScannedWaypoint
   */
  symbol: string
  /**
   *
   * @type {WaypointType}
   * @memberof ScannedWaypoint
   */
  type: WaypointType
  /**
   * The symbol of the system.
   * @type {string}
   * @memberof ScannedWaypoint
   */
  systemSymbol: string
  /**
   * Position in the universe in the x axis.
   * @type {number}
   * @memberof ScannedWaypoint
   */
  x: number
  /**
   * Position in the universe in the y axis.
   * @type {number}
   * @memberof ScannedWaypoint
   */
  y: number
  /**
   * List of waypoints that orbit this waypoint.
   * @type {Array<WaypointOrbital>}
   * @memberof ScannedWaypoint
   */
  orbitals: Array<WaypointOrbital>
  /**
   *
   * @type {WaypointFaction}
   * @memberof ScannedWaypoint
   */
  faction?: WaypointFaction
  /**
   * The traits of the waypoint.
   * @type {Array<WaypointTrait>}
   * @memberof ScannedWaypoint
   */
  traits: Array<WaypointTrait>
  /**
   *
   * @type {Chart}
   * @memberof ScannedWaypoint
   */
  chart?: Chart
}

/**
 *
 * @export
 * @interface SellCargo201Response
 */
export interface SellCargo201Response {
  /**
   *
   * @type {SellCargo201ResponseData}
   * @memberof SellCargo201Response
   */
  data: SellCargo201ResponseData
}
/**
 *
 * @export
 * @interface SellCargo201ResponseData
 */
export interface SellCargo201ResponseData {
  /**
   *
   * @type {Agent}
   * @memberof SellCargo201ResponseData
   */
  agent: Agent
  /**
   *
   * @type {ShipCargo}
   * @memberof SellCargo201ResponseData
   */
  cargo: ShipCargo
  /**
   *
   * @type {MarketTransaction}
   * @memberof SellCargo201ResponseData
   */
  transaction: MarketTransaction
}
/**
 *
 * @export
 * @interface SellCargoRequest
 */
export interface SellCargoRequest {
  /**
   *
   * @type {TradeSymbol}
   * @memberof SellCargoRequest
   */
  symbol: TradeSymbol
  /**
   * Amounts of units to sell of the selected good.
   * @type {number}
   * @memberof SellCargoRequest
   */
  units: number
}

/**
 * Ship details.
 * @export
 * @interface Ship
 */
export interface Ship {
  /**
   * The globally unique identifier of the ship in the following format: `[AGENT_SYMBOL]-[HEX_ID]`
   * @type {string}
   * @memberof Ship
   */
  symbol: string
  /**
   *
   * @type {ShipRegistration}
   * @memberof Ship
   */
  registration: ShipRegistration
  /**
   *
   * @type {ShipNav}
   * @memberof Ship
   */
  nav: ShipNav
  /**
   *
   * @type {ShipCrew}
   * @memberof Ship
   */
  crew: ShipCrew
  /**
   *
   * @type {ShipFrame}
   * @memberof Ship
   */
  frame: ShipFrame
  /**
   *
   * @type {ShipReactor}
   * @memberof Ship
   */
  reactor: ShipReactor
  /**
   *
   * @type {ShipEngine}
   * @memberof Ship
   */
  engine: ShipEngine
  /**
   *
   * @type {Cooldown}
   * @memberof Ship
   */
  cooldown: Cooldown
  /**
   * Modules installed in this ship.
   * @type {Array<ShipModule>}
   * @memberof Ship
   */
  modules: Array<ShipModule>
  /**
   * Mounts installed in this ship.
   * @type {Array<ShipMount>}
   * @memberof Ship
   */
  mounts: Array<ShipMount>
  /**
   *
   * @type {ShipCargo}
   * @memberof Ship
   */
  cargo: ShipCargo
  /**
   *
   * @type {ShipFuel}
   * @memberof Ship
   */
  fuel: ShipFuel
}
/**
 * Ship cargo details.
 * @export
 * @interface ShipCargo
 */
export interface ShipCargo {
  /**
   * The max number of items that can be stored in the cargo hold.
   * @type {number}
   * @memberof ShipCargo
   */
  capacity: number
  /**
   * The number of items currently stored in the cargo hold.
   * @type {number}
   * @memberof ShipCargo
   */
  units: number
  /**
   * The items currently in the cargo hold.
   * @type {Array<ShipCargoItem>}
   * @memberof ShipCargo
   */
  inventory: Array<ShipCargoItem>
}
/**
 * The type of cargo item and the number of units.
 * @export
 * @interface ShipCargoItem
 */
export interface ShipCargoItem {
  /**
   *
   * @type {TradeSymbol}
   * @memberof ShipCargoItem
   */
  symbol: TradeSymbol
  /**
   * The name of the cargo item type.
   * @type {string}
   * @memberof ShipCargoItem
   */
  name: string
  /**
   * The description of the cargo item type.
   * @type {string}
   * @memberof ShipCargoItem
   */
  description: string
  /**
   * The number of units of the cargo item.
   * @type {number}
   * @memberof ShipCargoItem
   */
  units: number
}

/**
 * The ship\'s crew service and maintain the ship\'s systems and equipment.
 * @export
 * @interface ShipCrew
 */
export interface ShipCrew {
  /**
   * The current number of crew members on the ship.
   * @type {number}
   * @memberof ShipCrew
   */
  current: number
  /**
   * The minimum number of crew members required to maintain the ship.
   * @type {number}
   * @memberof ShipCrew
   */
  required: number
  /**
   * The maximum number of crew members the ship can support.
   * @type {number}
   * @memberof ShipCrew
   */
  capacity: number
  /**
   * The rotation of crew shifts. A stricter shift improves the ship\'s performance. A more relaxed shift improves the crew\'s morale.
   * @type {string}
   * @memberof ShipCrew
   */
  rotation: ShipCrewRotationEnum
  /**
   * A rough measure of the crew\'s morale. A higher morale means the crew is happier and more productive. A lower morale means the ship is more prone to accidents.
   * @type {number}
   * @memberof ShipCrew
   */
  morale: number
  /**
   * The amount of credits per crew member paid per hour. Wages are paid when a ship docks at a civilized waypoint.
   * @type {number}
   * @memberof ShipCrew
   */
  wages: number
}

export const ShipCrewRotationEnum = {
  Strict: 'STRICT',
  Relaxed: 'RELAXED',
} as const

export type ShipCrewRotationEnum = (typeof ShipCrewRotationEnum)[keyof typeof ShipCrewRotationEnum]

/**
 * The engine determines how quickly a ship travels between waypoints.
 * @export
 * @interface ShipEngine
 */
export interface ShipEngine {
  /**
   * The symbol of the engine.
   * @type {string}
   * @memberof ShipEngine
   */
  symbol: ShipEngineSymbolEnum
  /**
   * The name of the engine.
   * @type {string}
   * @memberof ShipEngine
   */
  name: string
  /**
   * The description of the engine.
   * @type {string}
   * @memberof ShipEngine
   */
  description: string
  /**
   * Condition is a range of 0 to 100 where 0 is completely worn out and 100 is brand new.
   * @type {number}
   * @memberof ShipEngine
   */
  condition?: number
  /**
   * The speed stat of this engine. The higher the speed, the faster a ship can travel from one point to another. Reduces the time of arrival when navigating the ship.
   * @type {number}
   * @memberof ShipEngine
   */
  speed: number
  /**
   *
   * @type {ShipRequirements}
   * @memberof ShipEngine
   */
  requirements: ShipRequirements
}

export const ShipEngineSymbolEnum = {
  ImpulseDriveI: 'ENGINE_IMPULSE_DRIVE_I',
  IonDriveI: 'ENGINE_ION_DRIVE_I',
  IonDriveIi: 'ENGINE_ION_DRIVE_II',
  HyperDriveI: 'ENGINE_HYPER_DRIVE_I',
} as const

export type ShipEngineSymbolEnum = (typeof ShipEngineSymbolEnum)[keyof typeof ShipEngineSymbolEnum]

/**
 * The frame of the ship. The frame determines the number of modules and mounting points of the ship, as well as base fuel capacity. As the condition of the frame takes more wear, the ship will become more sluggish and less maneuverable.
 * @export
 * @interface ShipFrame
 */
export interface ShipFrame {
  /**
   * Symbol of the frame.
   * @type {string}
   * @memberof ShipFrame
   */
  symbol: ShipFrameSymbolEnum
  /**
   * Name of the frame.
   * @type {string}
   * @memberof ShipFrame
   */
  name: string
  /**
   * Description of the frame.
   * @type {string}
   * @memberof ShipFrame
   */
  description: string
  /**
   * Condition is a range of 0 to 100 where 0 is completely worn out and 100 is brand new.
   * @type {number}
   * @memberof ShipFrame
   */
  condition?: number
  /**
   * The amount of slots that can be dedicated to modules installed in the ship. Each installed module take up a number of slots, and once there are no more slots, no new modules can be installed.
   * @type {number}
   * @memberof ShipFrame
   */
  moduleSlots: number
  /**
   * The amount of slots that can be dedicated to mounts installed in the ship. Each installed mount takes up a number of points, and once there are no more points remaining, no new mounts can be installed.
   * @type {number}
   * @memberof ShipFrame
   */
  mountingPoints: number
  /**
   * The maximum amount of fuel that can be stored in this ship. When refueling, the ship will be refueled to this amount.
   * @type {number}
   * @memberof ShipFrame
   */
  fuelCapacity: number
  /**
   *
   * @type {ShipRequirements}
   * @memberof ShipFrame
   */
  requirements: ShipRequirements
}

export const ShipFrameSymbolEnum = {
  Probe: 'FRAME_PROBE',
  Drone: 'FRAME_DRONE',
  Interceptor: 'FRAME_INTERCEPTOR',
  Racer: 'FRAME_RACER',
  Fighter: 'FRAME_FIGHTER',
  Frigate: 'FRAME_FRIGATE',
  Shuttle: 'FRAME_SHUTTLE',
  Explorer: 'FRAME_EXPLORER',
  Miner: 'FRAME_MINER',
  LightFreighter: 'FRAME_LIGHT_FREIGHTER',
  HeavyFreighter: 'FRAME_HEAVY_FREIGHTER',
  Transport: 'FRAME_TRANSPORT',
  Destroyer: 'FRAME_DESTROYER',
  Cruiser: 'FRAME_CRUISER',
  Carrier: 'FRAME_CARRIER',
} as const

export type ShipFrameSymbolEnum = (typeof ShipFrameSymbolEnum)[keyof typeof ShipFrameSymbolEnum]

/**
 * Details of the ship\'s fuel tanks including how much fuel was consumed during the last transit or action.
 * @export
 * @interface ShipFuel
 */
export interface ShipFuel {
  /**
   * The current amount of fuel in the ship\'s tanks.
   * @type {number}
   * @memberof ShipFuel
   */
  current: number
  /**
   * The maximum amount of fuel the ship\'s tanks can hold.
   * @type {number}
   * @memberof ShipFuel
   */
  capacity: number
  /**
   *
   * @type {ShipFuelConsumed}
   * @memberof ShipFuel
   */
  consumed?: ShipFuelConsumed
}
/**
 * An object that only shows up when an action has consumed fuel in the process. Shows the fuel consumption data.
 * @export
 * @interface ShipFuelConsumed
 */
export interface ShipFuelConsumed {
  /**
   * The amount of fuel consumed by the most recent transit or action.
   * @type {number}
   * @memberof ShipFuelConsumed
   */
  amount: number
  /**
   * The time at which the fuel was consumed.
   * @type {string}
   * @memberof ShipFuelConsumed
   */
  timestamp: string
}
/**
 * Result of a transaction for a ship modification, such as installing a mount or a module.
 * @export
 * @interface ShipModificationTransaction
 */
export interface ShipModificationTransaction {
  /**
   * The symbol of the waypoint where the transaction took place.
   * @type {string}
   * @memberof ShipModificationTransaction
   */
  waypointSymbol: string
  /**
   * The symbol of the ship that made the transaction.
   * @type {string}
   * @memberof ShipModificationTransaction
   */
  shipSymbol: string
  /**
   * The symbol of the trade good.
   * @type {string}
   * @memberof ShipModificationTransaction
   */
  tradeSymbol: string
  /**
   * The total price of the transaction.
   * @type {number}
   * @memberof ShipModificationTransaction
   */
  totalPrice: number
  /**
   * The timestamp of the transaction.
   * @type {string}
   * @memberof ShipModificationTransaction
   */
  timestamp: string
}

/**
 * A module can be installed in a ship and provides a set of capabilities such as storage space or quarters for crew. Module installations are permanent.
 * @export
 * @interface ShipModule
 */
export interface ShipModule {
  /**
   * The symbol of the module.
   * @type {string}
   * @memberof ShipModule
   */
  symbol: ShipModuleSymbolEnum
  /**
   * Modules that provide capacity, such as cargo hold or crew quarters will show this value to denote how much of a bonus the module grants.
   * @type {number}
   * @memberof ShipModule
   */
  capacity?: number
  /**
   * Modules that have a range will such as a sensor array show this value to denote how far can the module reach with its capabilities.
   * @type {number}
   * @memberof ShipModule
   */
  range?: number
  /**
   * Name of this module.
   * @type {string}
   * @memberof ShipModule
   */
  name: string
  /**
   * Description of this module.
   * @type {string}
   * @memberof ShipModule
   */
  description: string
  /**
   *
   * @type {ShipRequirements}
   * @memberof ShipModule
   */
  requirements: ShipRequirements
}

export const ShipModuleSymbolEnum = {
  MineralProcessorI: 'MODULE_MINERAL_PROCESSOR_I',
  GasProcessorI: 'MODULE_GAS_PROCESSOR_I',
  CargoHoldI: 'MODULE_CARGO_HOLD_I',
  CargoHoldIi: 'MODULE_CARGO_HOLD_II',
  CargoHoldIii: 'MODULE_CARGO_HOLD_III',
  CrewQuartersI: 'MODULE_CREW_QUARTERS_I',
  EnvoyQuartersI: 'MODULE_ENVOY_QUARTERS_I',
  PassengerCabinI: 'MODULE_PASSENGER_CABIN_I',
  MicroRefineryI: 'MODULE_MICRO_REFINERY_I',
  OreRefineryI: 'MODULE_ORE_REFINERY_I',
  FuelRefineryI: 'MODULE_FUEL_REFINERY_I',
  ScienceLabI: 'MODULE_SCIENCE_LAB_I',
  JumpDriveI: 'MODULE_JUMP_DRIVE_I',
  JumpDriveIi: 'MODULE_JUMP_DRIVE_II',
  JumpDriveIii: 'MODULE_JUMP_DRIVE_III',
  WarpDriveI: 'MODULE_WARP_DRIVE_I',
  WarpDriveIi: 'MODULE_WARP_DRIVE_II',
  WarpDriveIii: 'MODULE_WARP_DRIVE_III',
  ShieldGeneratorI: 'MODULE_SHIELD_GENERATOR_I',
  ShieldGeneratorIi: 'MODULE_SHIELD_GENERATOR_II',
} as const

export type ShipModuleSymbolEnum = (typeof ShipModuleSymbolEnum)[keyof typeof ShipModuleSymbolEnum]

/**
 * A mount is installed on the exterier of a ship.
 * @export
 * @interface ShipMount
 */
export interface ShipMount {
  /**
   * Symbo of this mount.
   * @type {string}
   * @memberof ShipMount
   */
  symbol: ShipMountSymbolEnum
  /**
   * Name of this mount.
   * @type {string}
   * @memberof ShipMount
   */
  name: string
  /**
   * Description of this mount.
   * @type {string}
   * @memberof ShipMount
   */
  description?: string
  /**
   * Mounts that have this value, such as mining lasers, denote how powerful this mount\'s capabilities are.
   * @type {number}
   * @memberof ShipMount
   */
  strength?: number
  /**
   * Mounts that have this value denote what goods can be produced from using the mount.
   * @type {Array<string>}
   * @memberof ShipMount
   */
  deposits?: Array<ShipMountDepositsEnum>
  /**
   *
   * @type {ShipRequirements}
   * @memberof ShipMount
   */
  requirements: ShipRequirements
}

export const ShipMountSymbolEnum = {
  GasSiphonI: 'MOUNT_GAS_SIPHON_I',
  GasSiphonIi: 'MOUNT_GAS_SIPHON_II',
  GasSiphonIii: 'MOUNT_GAS_SIPHON_III',
  SurveyorI: 'MOUNT_SURVEYOR_I',
  SurveyorIi: 'MOUNT_SURVEYOR_II',
  SurveyorIii: 'MOUNT_SURVEYOR_III',
  SensorArrayI: 'MOUNT_SENSOR_ARRAY_I',
  SensorArrayIi: 'MOUNT_SENSOR_ARRAY_II',
  SensorArrayIii: 'MOUNT_SENSOR_ARRAY_III',
  MiningLaserI: 'MOUNT_MINING_LASER_I',
  MiningLaserIi: 'MOUNT_MINING_LASER_II',
  MiningLaserIii: 'MOUNT_MINING_LASER_III',
  LaserCannonI: 'MOUNT_LASER_CANNON_I',
  MissileLauncherI: 'MOUNT_MISSILE_LAUNCHER_I',
  TurretI: 'MOUNT_TURRET_I',
} as const

export type ShipMountSymbolEnum = (typeof ShipMountSymbolEnum)[keyof typeof ShipMountSymbolEnum]
export const ShipMountDepositsEnum = {
  QuartzSand: 'QUARTZ_SAND',
  SiliconCrystals: 'SILICON_CRYSTALS',
  PreciousStones: 'PRECIOUS_STONES',
  IceWater: 'ICE_WATER',
  AmmoniaIce: 'AMMONIA_ICE',
  IronOre: 'IRON_ORE',
  CopperOre: 'COPPER_ORE',
  SilverOre: 'SILVER_ORE',
  AluminumOre: 'ALUMINUM_ORE',
  GoldOre: 'GOLD_ORE',
  PlatinumOre: 'PLATINUM_ORE',
  Diamonds: 'DIAMONDS',
  UraniteOre: 'URANITE_ORE',
  MeritiumOre: 'MERITIUM_ORE',
} as const

export type ShipMountDepositsEnum = (typeof ShipMountDepositsEnum)[keyof typeof ShipMountDepositsEnum]

/**
 * The navigation information of the ship.
 * @export
 * @interface ShipNav
 */
export interface ShipNav {
  /**
   * The symbol of the system.
   * @type {string}
   * @memberof ShipNav
   */
  systemSymbol: string
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof ShipNav
   */
  waypointSymbol: string
  /**
   *
   * @type {ShipNavRoute}
   * @memberof ShipNav
   */
  route: ShipNavRoute
  /**
   *
   * @type {ShipNavStatus}
   * @memberof ShipNav
   */
  status: ShipNavStatus
  /**
   *
   * @type {ShipNavFlightMode}
   * @memberof ShipNav
   */
  flightMode: ShipNavFlightMode
}

/**
 * The ship\'s set speed when traveling between waypoints or systems.
 * @export
 * @enum {string}
 */

export const ShipNavFlightMode = {
  Drift: 'DRIFT',
  Stealth: 'STEALTH',
  Cruise: 'CRUISE',
  Burn: 'BURN',
} as const

export type ShipNavFlightMode = (typeof ShipNavFlightMode)[keyof typeof ShipNavFlightMode]

/**
 * The routing information for the ship\'s most recent transit or current location.
 * @export
 * @interface ShipNavRoute
 */
export interface ShipNavRoute {
  /**
   *
   * @type {ShipNavRouteWaypoint}
   * @memberof ShipNavRoute
   */
  destination: ShipNavRouteWaypoint
  /**
   *
   * @type {ShipNavRouteWaypoint}
   * @memberof ShipNavRoute
   */
  origin: ShipNavRouteWaypoint
  /**
   * The date time of the ship\'s departure.
   * @type {string}
   * @memberof ShipNavRoute
   */
  departureTime: string
  /**
   * The date time of the ship\'s arrival. If the ship is in-transit, this is the expected time of arrival.
   * @type {string}
   * @memberof ShipNavRoute
   */
  arrival: string
}
/**
 * The destination or departure of a ships nav route.
 * @export
 * @interface ShipNavRouteWaypoint
 */
export interface ShipNavRouteWaypoint {
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof ShipNavRouteWaypoint
   */
  symbol: string
  /**
   *
   * @type {WaypointType}
   * @memberof ShipNavRouteWaypoint
   */
  type: WaypointType
  /**
   * The symbol of the system.
   * @type {string}
   * @memberof ShipNavRouteWaypoint
   */
  systemSymbol: string
  /**
   * Position in the universe in the x axis.
   * @type {number}
   * @memberof ShipNavRouteWaypoint
   */
  x: number
  /**
   * Position in the universe in the y axis.
   * @type {number}
   * @memberof ShipNavRouteWaypoint
   */
  y: number
}

/**
 * The current status of the ship
 * @export
 * @enum {string}
 */

export const ShipNavStatus = {
  InTransit: 'IN_TRANSIT',
  InOrbit: 'IN_ORBIT',
  Docked: 'DOCKED',
} as const

export type ShipNavStatus = (typeof ShipNavStatus)[keyof typeof ShipNavStatus]

/**
 * The reactor of the ship. The reactor is responsible for powering the ship\'s systems and weapons.
 * @export
 * @interface ShipReactor
 */
export interface ShipReactor {
  /**
   * Symbol of the reactor.
   * @type {string}
   * @memberof ShipReactor
   */
  symbol: ShipReactorSymbolEnum
  /**
   * Name of the reactor.
   * @type {string}
   * @memberof ShipReactor
   */
  name: string
  /**
   * Description of the reactor.
   * @type {string}
   * @memberof ShipReactor
   */
  description: string
  /**
   * Condition is a range of 0 to 100 where 0 is completely worn out and 100 is brand new.
   * @type {number}
   * @memberof ShipReactor
   */
  condition?: number
  /**
   * The amount of power provided by this reactor. The more power a reactor provides to the ship, the lower the cooldown it gets when using a module or mount that taxes the ship\'s power.
   * @type {number}
   * @memberof ShipReactor
   */
  powerOutput: number
  /**
   *
   * @type {ShipRequirements}
   * @memberof ShipReactor
   */
  requirements: ShipRequirements
}

export const ShipReactorSymbolEnum = {
  SolarI: 'REACTOR_SOLAR_I',
  FusionI: 'REACTOR_FUSION_I',
  FissionI: 'REACTOR_FISSION_I',
  ChemicalI: 'REACTOR_CHEMICAL_I',
  AntimatterI: 'REACTOR_ANTIMATTER_I',
} as const

export type ShipReactorSymbolEnum = (typeof ShipReactorSymbolEnum)[keyof typeof ShipReactorSymbolEnum]

/**
 *
 * @export
 * @interface ShipRefine201Response
 */
export interface ShipRefine201Response {
  /**
   *
   * @type {ShipRefine201ResponseData}
   * @memberof ShipRefine201Response
   */
  data: ShipRefine201ResponseData
}
/**
 *
 * @export
 * @interface ShipRefine201ResponseData
 */
export interface ShipRefine201ResponseData {
  /**
   *
   * @type {ShipCargo}
   * @memberof ShipRefine201ResponseData
   */
  cargo: ShipCargo
  /**
   *
   * @type {Cooldown}
   * @memberof ShipRefine201ResponseData
   */
  cooldown: Cooldown
  /**
   * Goods that were produced by this refining process.
   * @type {Array<ShipRefine201ResponseDataProducedInner>}
   * @memberof ShipRefine201ResponseData
   */
  produced: Array<ShipRefine201ResponseDataProducedInner>
  /**
   * Goods that were consumed during this refining process.
   * @type {Array<ShipRefine201ResponseDataProducedInner>}
   * @memberof ShipRefine201ResponseData
   */
  consumed: Array<ShipRefine201ResponseDataProducedInner>
}
/**
 *
 * @export
 * @interface ShipRefine201ResponseDataProducedInner
 */
export interface ShipRefine201ResponseDataProducedInner {
  /**
   * Symbol of the good.
   * @type {string}
   * @memberof ShipRefine201ResponseDataProducedInner
   */
  tradeSymbol: string
  /**
   * Amount of units of the good.
   * @type {number}
   * @memberof ShipRefine201ResponseDataProducedInner
   */
  units: number
}
/**
 *
 * @export
 * @interface ShipRefineRequest
 */
export interface ShipRefineRequest {
  /**
   * The type of good to produce out of the refining process.
   * @type {string}
   * @memberof ShipRefineRequest
   */
  produce: ShipRefineRequestProduceEnum
}

export const ShipRefineRequestProduceEnum = {
  Iron: 'IRON',
  Copper: 'COPPER',
  Silver: 'SILVER',
  Gold: 'GOLD',
  Aluminum: 'ALUMINUM',
  Platinum: 'PLATINUM',
  Uranite: 'URANITE',
  Meritium: 'MERITIUM',
  Fuel: 'FUEL',
} as const

export type ShipRefineRequestProduceEnum = (typeof ShipRefineRequestProduceEnum)[keyof typeof ShipRefineRequestProduceEnum]

/**
 * The public registration information of the ship
 * @export
 * @interface ShipRegistration
 */
export interface ShipRegistration {
  /**
   * The agent\'s registered name of the ship
   * @type {string}
   * @memberof ShipRegistration
   */
  name: string
  /**
   * The symbol of the faction the ship is registered with
   * @type {string}
   * @memberof ShipRegistration
   */
  factionSymbol: string
  /**
   *
   * @type {ShipRole}
   * @memberof ShipRegistration
   */
  role: ShipRole
}

/**
 * The requirements for installation on a ship
 * @export
 * @interface ShipRequirements
 */
export interface ShipRequirements {
  /**
   * The amount of power required from the reactor.
   * @type {number}
   * @memberof ShipRequirements
   */
  power?: number
  /**
   * The number of crew required for operation.
   * @type {number}
   * @memberof ShipRequirements
   */
  crew?: number
  /**
   * The number of module slots required for installation.
   * @type {number}
   * @memberof ShipRequirements
   */
  slots?: number
}
/**
 * The registered role of the ship
 * @export
 * @enum {string}
 */

export const ShipRole = {
  Fabricator: 'FABRICATOR',
  Harvester: 'HARVESTER',
  Hauler: 'HAULER',
  Interceptor: 'INTERCEPTOR',
  Excavator: 'EXCAVATOR',
  Transport: 'TRANSPORT',
  Repair: 'REPAIR',
  Surveyor: 'SURVEYOR',
  Command: 'COMMAND',
  Carrier: 'CARRIER',
  Patrol: 'PATROL',
  Satellite: 'SATELLITE',
  Explorer: 'EXPLORER',
  Refinery: 'REFINERY',
} as const

export type ShipRole = (typeof ShipRole)[keyof typeof ShipRole]

/**
 * Type of ship
 * @export
 * @enum {string}
 */

export const ShipType = {
  Probe: 'SHIP_PROBE',
  MiningDrone: 'SHIP_MINING_DRONE',
  SiphonDrone: 'SHIP_SIPHON_DRONE',
  Interceptor: 'SHIP_INTERCEPTOR',
  LightHauler: 'SHIP_LIGHT_HAULER',
  CommandFrigate: 'SHIP_COMMAND_FRIGATE',
  Explorer: 'SHIP_EXPLORER',
  HeavyFreighter: 'SHIP_HEAVY_FREIGHTER',
  LightShuttle: 'SHIP_LIGHT_SHUTTLE',
  OreHound: 'SHIP_ORE_HOUND',
  RefiningFreighter: 'SHIP_REFINING_FREIGHTER',
  Surveyor: 'SHIP_SURVEYOR',
} as const

export type ShipType = (typeof ShipType)[keyof typeof ShipType]

/**
 *
 * @export
 * @interface Shipyard
 */
export interface Shipyard {
  /**
   * The symbol of the shipyard. The symbol is the same as the waypoint where the shipyard is located.
   * @type {string}
   * @memberof Shipyard
   */
  symbol: string
  /**
   * The list of ship types available for purchase at this shipyard.
   * @type {Array<ShipyardShipTypesInner>}
   * @memberof Shipyard
   */
  shipTypes: Array<ShipyardShipTypesInner>
  /**
   * The list of recent transactions at this shipyard.
   * @type {Array<ShipyardTransaction>}
   * @memberof Shipyard
   */
  transactions?: Array<ShipyardTransaction>
  /**
   * The ships that are currently available for purchase at the shipyard.
   * @type {Array<ShipyardShip>}
   * @memberof Shipyard
   */
  ships?: Array<ShipyardShip>
  /**
   * The fee to modify a ship at this shipyard. This includes installing or removing modules and mounts on a ship. In the case of mounts, the fee is a flat rate per mount. In the case of modules, the fee is per slot the module occupies.
   * @type {number}
   * @memberof Shipyard
   */
  modificationsFee: number
}
/**
 *
 * @export
 * @interface ShipyardShip
 */
export interface ShipyardShip {
  /**
   *
   * @type {ShipType}
   * @memberof ShipyardShip
   */
  type: ShipType
  /**
   *
   * @type {string}
   * @memberof ShipyardShip
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ShipyardShip
   */
  description: string
  /**
   *
   * @type {SupplyLevel}
   * @memberof ShipyardShip
   */
  supply: SupplyLevel
  /**
   *
   * @type {ActivityLevel}
   * @memberof ShipyardShip
   */
  activity?: ActivityLevel
  /**
   *
   * @type {number}
   * @memberof ShipyardShip
   */
  purchasePrice: number
  /**
   *
   * @type {ShipFrame}
   * @memberof ShipyardShip
   */
  frame: ShipFrame
  /**
   *
   * @type {ShipReactor}
   * @memberof ShipyardShip
   */
  reactor: ShipReactor
  /**
   *
   * @type {ShipEngine}
   * @memberof ShipyardShip
   */
  engine: ShipEngine
  /**
   *
   * @type {Array<ShipModule>}
   * @memberof ShipyardShip
   */
  modules: Array<ShipModule>
  /**
   *
   * @type {Array<ShipMount>}
   * @memberof ShipyardShip
   */
  mounts: Array<ShipMount>
  /**
   *
   * @type {ShipyardShipCrew}
   * @memberof ShipyardShip
   */
  crew: ShipyardShipCrew
}

/**
 *
 * @export
 * @interface ShipyardShipCrew
 */
export interface ShipyardShipCrew {
  /**
   *
   * @type {number}
   * @memberof ShipyardShipCrew
   */
  required: number
  /**
   *
   * @type {number}
   * @memberof ShipyardShipCrew
   */
  capacity: number
}
/**
 *
 * @export
 * @interface ShipyardShipTypesInner
 */
export interface ShipyardShipTypesInner {
  /**
   *
   * @type {ShipType}
   * @memberof ShipyardShipTypesInner
   */
  type: ShipType
}

/**
 * Results of a transaction with a shipyard.
 * @export
 * @interface ShipyardTransaction
 */
export interface ShipyardTransaction {
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof ShipyardTransaction
   */
  waypointSymbol: string
  /**
   * The symbol of the ship that was the subject of the transaction.
   * @type {string}
   * @memberof ShipyardTransaction
   * @deprecated
   */
  shipSymbol: string
  /**
   * The symbol of the ship that was the subject of the transaction.
   * @type {string}
   * @memberof ShipyardTransaction
   */
  shipType: string
  /**
   * The price of the transaction.
   * @type {number}
   * @memberof ShipyardTransaction
   */
  price: number
  /**
   * The symbol of the agent that made the transaction.
   * @type {string}
   * @memberof ShipyardTransaction
   */
  agentSymbol: string
  /**
   * The timestamp of the transaction.
   * @type {string}
   * @memberof ShipyardTransaction
   */
  timestamp: string
}
/**
 * Siphon details.
 * @export
 * @interface Siphon
 */
export interface Siphon {
  /**
   * Symbol of the ship that executed the siphon.
   * @type {string}
   * @memberof Siphon
   */
  shipSymbol: string
  /**
   *
   * @type {SiphonYield}
   * @memberof Siphon
   */
  yield: SiphonYield
}
/**
 *
 * @export
 * @interface SiphonResources201Response
 */
export interface SiphonResources201Response {
  /**
   *
   * @type {SiphonResources201ResponseData}
   * @memberof SiphonResources201Response
   */
  data: SiphonResources201ResponseData
}
/**
 *
 * @export
 * @interface SiphonResources201ResponseData
 */
export interface SiphonResources201ResponseData {
  /**
   *
   * @type {Cooldown}
   * @memberof SiphonResources201ResponseData
   */
  cooldown: Cooldown
  /**
   *
   * @type {Siphon}
   * @memberof SiphonResources201ResponseData
   */
  siphon: Siphon
  /**
   *
   * @type {ShipCargo}
   * @memberof SiphonResources201ResponseData
   */
  cargo: ShipCargo
}
/**
 * A yield from the siphon operation.
 * @export
 * @interface SiphonYield
 */
export interface SiphonYield {
  /**
   *
   * @type {TradeSymbol}
   * @memberof SiphonYield
   */
  symbol: TradeSymbol
  /**
   * The number of units siphoned that were placed into the ship\'s cargo hold.
   * @type {number}
   * @memberof SiphonYield
   */
  units: number
}

/**
 *
 * @export
 * @interface SupplyConstruction201Response
 */
export interface SupplyConstruction201Response {
  /**
   *
   * @type {SupplyConstruction201ResponseData}
   * @memberof SupplyConstruction201Response
   */
  data: SupplyConstruction201ResponseData
}
/**
 *
 * @export
 * @interface SupplyConstruction201ResponseData
 */
export interface SupplyConstruction201ResponseData {
  /**
   *
   * @type {Construction}
   * @memberof SupplyConstruction201ResponseData
   */
  construction: Construction
  /**
   *
   * @type {ShipCargo}
   * @memberof SupplyConstruction201ResponseData
   */
  cargo: ShipCargo
}
/**
 *
 * @export
 * @interface SupplyConstructionRequest
 */
export interface SupplyConstructionRequest {
  /**
   * Symbol of the ship to use.
   * @type {string}
   * @memberof SupplyConstructionRequest
   */
  shipSymbol: string
  /**
   * The symbol of the good to supply.
   * @type {string}
   * @memberof SupplyConstructionRequest
   */
  tradeSymbol: string
  /**
   * Amount of units to supply.
   * @type {number}
   * @memberof SupplyConstructionRequest
   */
  units: number
}
/**
 * The supply level of a trade good.
 * @export
 * @enum {string}
 */

export const SupplyLevel = {
  Scarce: 'SCARCE',
  Limited: 'LIMITED',
  Moderate: 'MODERATE',
  High: 'HIGH',
  Abundant: 'ABUNDANT',
} as const

export type SupplyLevel = (typeof SupplyLevel)[keyof typeof SupplyLevel]

/**
 * A resource survey of a waypoint, detailing a specific extraction location and the types of resources that can be found there.
 * @export
 * @interface Survey
 */
export interface Survey {
  /**
   * A unique signature for the location of this survey. This signature is verified when attempting an extraction using this survey.
   * @type {string}
   * @memberof Survey
   */
  signature: string
  /**
   * The symbol of the waypoint that this survey is for.
   * @type {string}
   * @memberof Survey
   */
  symbol: string
  /**
   * A list of deposits that can be found at this location. A ship will extract one of these deposits when using this survey in an extraction request. If multiple deposits of the same type are present, the chance of extracting that deposit is increased.
   * @type {Array<SurveyDeposit>}
   * @memberof Survey
   */
  deposits: Array<SurveyDeposit>
  /**
   * The date and time when the survey expires. After this date and time, the survey will no longer be available for extraction.
   * @type {string}
   * @memberof Survey
   */
  expiration: string
  /**
   * The size of the deposit. This value indicates how much can be extracted from the survey before it is exhausted.
   * @type {string}
   * @memberof Survey
   */
  size: SurveySizeEnum
}

export const SurveySizeEnum = {
  Small: 'SMALL',
  Moderate: 'MODERATE',
  Large: 'LARGE',
} as const

export type SurveySizeEnum = (typeof SurveySizeEnum)[keyof typeof SurveySizeEnum]

/**
 * A surveyed deposit of a mineral or resource available for extraction.
 * @export
 * @interface SurveyDeposit
 */
export interface SurveyDeposit {
  /**
   * The symbol of the deposit.
   * @type {string}
   * @memberof SurveyDeposit
   */
  symbol: string
}
/**
 *
 * @export
 * @interface System
 */
export interface System {
  /**
   * The symbol of the system.
   * @type {string}
   * @memberof System
   */
  symbol: string
  /**
   * The symbol of the sector.
   * @type {string}
   * @memberof System
   */
  sectorSymbol: string
  /**
   *
   * @type {SystemType}
   * @memberof System
   */
  type: SystemType
  /**
   * Relative position of the system in the sector in the x axis.
   * @type {number}
   * @memberof System
   */
  x: number
  /**
   * Relative position of the system in the sector in the y axis.
   * @type {number}
   * @memberof System
   */
  y: number
  /**
   * Waypoints in this system.
   * @type {Array<SystemWaypoint>}
   * @memberof System
   */
  waypoints: Array<SystemWaypoint>
  /**
   * Factions that control this system.
   * @type {Array<SystemFaction>}
   * @memberof System
   */
  factions: Array<SystemFaction>
}

/**
 *
 * @export
 * @interface SystemFaction
 */
export interface SystemFaction {
  /**
   *
   * @type {FactionSymbol}
   * @memberof SystemFaction
   */
  symbol: FactionSymbol
}

/**
 * The type of system.
 * @export
 * @enum {string}
 */

export const SystemType = {
  NeutronStar: 'NEUTRON_STAR',
  RedStar: 'RED_STAR',
  OrangeStar: 'ORANGE_STAR',
  BlueStar: 'BLUE_STAR',
  YoungStar: 'YOUNG_STAR',
  WhiteDwarf: 'WHITE_DWARF',
  BlackHole: 'BLACK_HOLE',
  Hypergiant: 'HYPERGIANT',
  Nebula: 'NEBULA',
  Unstable: 'UNSTABLE',
} as const

export type SystemType = (typeof SystemType)[keyof typeof SystemType]

/**
 *
 * @export
 * @interface SystemWaypoint
 */
export interface SystemWaypoint {
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof SystemWaypoint
   */
  symbol: string
  /**
   *
   * @type {WaypointType}
   * @memberof SystemWaypoint
   */
  type: WaypointType
  /**
   * Relative position of the waypoint on the system\'s x axis. This is not an absolute position in the universe.
   * @type {number}
   * @memberof SystemWaypoint
   */
  x: number
  /**
   * Relative position of the waypoint on the system\'s y axis. This is not an absolute position in the universe.
   * @type {number}
   * @memberof SystemWaypoint
   */
  y: number
  /**
   * Waypoints that orbit this waypoint.
   * @type {Array<WaypointOrbital>}
   * @memberof SystemWaypoint
   */
  orbitals: Array<WaypointOrbital>
  /**
   * The symbol of the parent waypoint, if this waypoint is in orbit around another waypoint. Otherwise this value is undefined.
   * @type {string}
   * @memberof SystemWaypoint
   */
  orbits?: string
}

/**
 * A good that can be traded for other goods or currency.
 * @export
 * @interface TradeGood
 */
export interface TradeGood {
  /**
   *
   * @type {TradeSymbol}
   * @memberof TradeGood
   */
  symbol: TradeSymbol
  /**
   * The name of the good.
   * @type {string}
   * @memberof TradeGood
   */
  name: string
  /**
   * The description of the good.
   * @type {string}
   * @memberof TradeGood
   */
  description: string
}

/**
 * The good\'s symbol.
 * @export
 * @enum {string}
 */

export const TradeSymbol = {
  PreciousStones: 'PRECIOUS_STONES',
  QuartzSand: 'QUARTZ_SAND',
  SiliconCrystals: 'SILICON_CRYSTALS',
  AmmoniaIce: 'AMMONIA_ICE',
  LiquidHydrogen: 'LIQUID_HYDROGEN',
  LiquidNitrogen: 'LIQUID_NITROGEN',
  IceWater: 'ICE_WATER',
  ExoticMatter: 'EXOTIC_MATTER',
  AdvancedCircuitry: 'ADVANCED_CIRCUITRY',
  GravitonEmitters: 'GRAVITON_EMITTERS',
  Iron: 'IRON',
  IronOre: 'IRON_ORE',
  Copper: 'COPPER',
  CopperOre: 'COPPER_ORE',
  Aluminum: 'ALUMINUM',
  AluminumOre: 'ALUMINUM_ORE',
  Silver: 'SILVER',
  SilverOre: 'SILVER_ORE',
  Gold: 'GOLD',
  GoldOre: 'GOLD_ORE',
  Platinum: 'PLATINUM',
  PlatinumOre: 'PLATINUM_ORE',
  Diamonds: 'DIAMONDS',
  Uranite: 'URANITE',
  UraniteOre: 'URANITE_ORE',
  Meritium: 'MERITIUM',
  MeritiumOre: 'MERITIUM_ORE',
  Hydrocarbon: 'HYDROCARBON',
  Antimatter: 'ANTIMATTER',
  FabMats: 'FAB_MATS',
  Fertilizers: 'FERTILIZERS',
  Fabrics: 'FABRICS',
  Food: 'FOOD',
  Jewelry: 'JEWELRY',
  Machinery: 'MACHINERY',
  Firearms: 'FIREARMS',
  AssaultRifles: 'ASSAULT_RIFLES',
  MilitaryEquipment: 'MILITARY_EQUIPMENT',
  Explosives: 'EXPLOSIVES',
  LabInstruments: 'LAB_INSTRUMENTS',
  Ammunition: 'AMMUNITION',
  Electronics: 'ELECTRONICS',
  ShipPlating: 'SHIP_PLATING',
  ShipParts: 'SHIP_PARTS',
  Equipment: 'EQUIPMENT',
  Fuel: 'FUEL',
  Medicine: 'MEDICINE',
  Drugs: 'DRUGS',
  Clothing: 'CLOTHING',
  Microprocessors: 'MICROPROCESSORS',
  Plastics: 'PLASTICS',
  Polynucleotides: 'POLYNUCLEOTIDES',
  Biocomposites: 'BIOCOMPOSITES',
  QuantumStabilizers: 'QUANTUM_STABILIZERS',
  Nanobots: 'NANOBOTS',
  AiMainframes: 'AI_MAINFRAMES',
  QuantumDrives: 'QUANTUM_DRIVES',
  RoboticDrones: 'ROBOTIC_DRONES',
  CyberImplants: 'CYBER_IMPLANTS',
  GeneTherapeutics: 'GENE_THERAPEUTICS',
  NeuralChips: 'NEURAL_CHIPS',
  MoodRegulators: 'MOOD_REGULATORS',
  ViralAgents: 'VIRAL_AGENTS',
  MicroFusionGenerators: 'MICRO_FUSION_GENERATORS',
  Supergrains: 'SUPERGRAINS',
  LaserRifles: 'LASER_RIFLES',
  Holographics: 'HOLOGRAPHICS',
  ShipSalvage: 'SHIP_SALVAGE',
  RelicTech: 'RELIC_TECH',
  NovelLifeforms: 'NOVEL_LIFEFORMS',
  BotanicalSpecimens: 'BOTANICAL_SPECIMENS',
  CulturalArtifacts: 'CULTURAL_ARTIFACTS',
  FrameProbe: 'FRAME_PROBE',
  FrameDrone: 'FRAME_DRONE',
  FrameInterceptor: 'FRAME_INTERCEPTOR',
  FrameRacer: 'FRAME_RACER',
  FrameFighter: 'FRAME_FIGHTER',
  FrameFrigate: 'FRAME_FRIGATE',
  FrameShuttle: 'FRAME_SHUTTLE',
  FrameExplorer: 'FRAME_EXPLORER',
  FrameMiner: 'FRAME_MINER',
  FrameLightFreighter: 'FRAME_LIGHT_FREIGHTER',
  FrameHeavyFreighter: 'FRAME_HEAVY_FREIGHTER',
  FrameTransport: 'FRAME_TRANSPORT',
  FrameDestroyer: 'FRAME_DESTROYER',
  FrameCruiser: 'FRAME_CRUISER',
  FrameCarrier: 'FRAME_CARRIER',
  ReactorSolarI: 'REACTOR_SOLAR_I',
  ReactorFusionI: 'REACTOR_FUSION_I',
  ReactorFissionI: 'REACTOR_FISSION_I',
  ReactorChemicalI: 'REACTOR_CHEMICAL_I',
  ReactorAntimatterI: 'REACTOR_ANTIMATTER_I',
  EngineImpulseDriveI: 'ENGINE_IMPULSE_DRIVE_I',
  EngineIonDriveI: 'ENGINE_ION_DRIVE_I',
  EngineIonDriveIi: 'ENGINE_ION_DRIVE_II',
  EngineHyperDriveI: 'ENGINE_HYPER_DRIVE_I',
  ModuleMineralProcessorI: 'MODULE_MINERAL_PROCESSOR_I',
  ModuleGasProcessorI: 'MODULE_GAS_PROCESSOR_I',
  ModuleCargoHoldI: 'MODULE_CARGO_HOLD_I',
  ModuleCargoHoldIi: 'MODULE_CARGO_HOLD_II',
  ModuleCargoHoldIii: 'MODULE_CARGO_HOLD_III',
  ModuleCrewQuartersI: 'MODULE_CREW_QUARTERS_I',
  ModuleEnvoyQuartersI: 'MODULE_ENVOY_QUARTERS_I',
  ModulePassengerCabinI: 'MODULE_PASSENGER_CABIN_I',
  ModuleMicroRefineryI: 'MODULE_MICRO_REFINERY_I',
  ModuleScienceLabI: 'MODULE_SCIENCE_LAB_I',
  ModuleJumpDriveI: 'MODULE_JUMP_DRIVE_I',
  ModuleJumpDriveIi: 'MODULE_JUMP_DRIVE_II',
  ModuleJumpDriveIii: 'MODULE_JUMP_DRIVE_III',
  ModuleWarpDriveI: 'MODULE_WARP_DRIVE_I',
  ModuleWarpDriveIi: 'MODULE_WARP_DRIVE_II',
  ModuleWarpDriveIii: 'MODULE_WARP_DRIVE_III',
  ModuleShieldGeneratorI: 'MODULE_SHIELD_GENERATOR_I',
  ModuleShieldGeneratorIi: 'MODULE_SHIELD_GENERATOR_II',
  ModuleOreRefineryI: 'MODULE_ORE_REFINERY_I',
  ModuleFuelRefineryI: 'MODULE_FUEL_REFINERY_I',
  MountGasSiphonI: 'MOUNT_GAS_SIPHON_I',
  MountGasSiphonIi: 'MOUNT_GAS_SIPHON_II',
  MountGasSiphonIii: 'MOUNT_GAS_SIPHON_III',
  MountSurveyorI: 'MOUNT_SURVEYOR_I',
  MountSurveyorIi: 'MOUNT_SURVEYOR_II',
  MountSurveyorIii: 'MOUNT_SURVEYOR_III',
  MountSensorArrayI: 'MOUNT_SENSOR_ARRAY_I',
  MountSensorArrayIi: 'MOUNT_SENSOR_ARRAY_II',
  MountSensorArrayIii: 'MOUNT_SENSOR_ARRAY_III',
  MountMiningLaserI: 'MOUNT_MINING_LASER_I',
  MountMiningLaserIi: 'MOUNT_MINING_LASER_II',
  MountMiningLaserIii: 'MOUNT_MINING_LASER_III',
  MountLaserCannonI: 'MOUNT_LASER_CANNON_I',
  MountMissileLauncherI: 'MOUNT_MISSILE_LAUNCHER_I',
  MountTurretI: 'MOUNT_TURRET_I',
  ShipProbe: 'SHIP_PROBE',
  ShipMiningDrone: 'SHIP_MINING_DRONE',
  ShipSiphonDrone: 'SHIP_SIPHON_DRONE',
  ShipInterceptor: 'SHIP_INTERCEPTOR',
  ShipLightHauler: 'SHIP_LIGHT_HAULER',
  ShipCommandFrigate: 'SHIP_COMMAND_FRIGATE',
  ShipExplorer: 'SHIP_EXPLORER',
  ShipHeavyFreighter: 'SHIP_HEAVY_FREIGHTER',
  ShipLightShuttle: 'SHIP_LIGHT_SHUTTLE',
  ShipOreHound: 'SHIP_ORE_HOUND',
  ShipRefiningFreighter: 'SHIP_REFINING_FREIGHTER',
  ShipSurveyor: 'SHIP_SURVEYOR',
} as const

export type TradeSymbol = (typeof TradeSymbol)[keyof typeof TradeSymbol]

/**
 *
 * @export
 * @interface TransferCargo200Response
 */
export interface TransferCargo200Response {
  /**
   *
   * @type {Jettison200ResponseData}
   * @memberof TransferCargo200Response
   */
  data: Jettison200ResponseData
}
/**
 *
 * @export
 * @interface TransferCargoRequest
 */
export interface TransferCargoRequest {
  /**
   *
   * @type {TradeSymbol}
   * @memberof TransferCargoRequest
   */
  tradeSymbol: TradeSymbol
  /**
   * Amount of units to transfer.
   * @type {number}
   * @memberof TransferCargoRequest
   */
  units: number
  /**
   * The symbol of the ship to transfer to.
   * @type {string}
   * @memberof TransferCargoRequest
   */
  shipSymbol: string
}

/**
 * A waypoint is a location that ships can travel to such as a Planet, Moon or Space Station.
 * @export
 * @interface Waypoint
 */
export interface Waypoint {
  /**
   * The symbol of the waypoint.
   * @type {string}
   * @memberof Waypoint
   */
  symbol: string
  /**
   *
   * @type {WaypointType}
   * @memberof Waypoint
   */
  type: WaypointType
  /**
   * The symbol of the system.
   * @type {string}
   * @memberof Waypoint
   */
  systemSymbol: string
  /**
   * Relative position of the waypoint on the system\'s x axis. This is not an absolute position in the universe.
   * @type {number}
   * @memberof Waypoint
   */
  x: number
  /**
   * Relative position of the waypoint on the system\'s y axis. This is not an absolute position in the universe.
   * @type {number}
   * @memberof Waypoint
   */
  y: number
  /**
   * Waypoints that orbit this waypoint.
   * @type {Array<WaypointOrbital>}
   * @memberof Waypoint
   */
  orbitals: Array<WaypointOrbital>
  /**
   * The symbol of the parent waypoint, if this waypoint is in orbit around another waypoint. Otherwise this value is undefined.
   * @type {string}
   * @memberof Waypoint
   */
  orbits?: string
  /**
   *
   * @type {WaypointFaction}
   * @memberof Waypoint
   */
  faction?: WaypointFaction
  /**
   * The traits of the waypoint.
   * @type {Array<WaypointTrait>}
   * @memberof Waypoint
   */
  traits: Array<WaypointTrait>
  /**
   * The modifiers of the waypoint.
   * @type {Array<WaypointModifier>}
   * @memberof Waypoint
   */
  modifiers?: Array<WaypointModifier>
  /**
   *
   * @type {Chart}
   * @memberof Waypoint
   */
  chart?: Chart
  /**
   * True if the waypoint is under construction.
   * @type {boolean}
   * @memberof Waypoint
   */
  isUnderConstruction: boolean
}

/**
 * The faction that controls the waypoint.
 * @export
 * @interface WaypointFaction
 */
export interface WaypointFaction {
  /**
   *
   * @type {FactionSymbol}
   * @memberof WaypointFaction
   */
  symbol: FactionSymbol
}

/**
 *
 * @export
 * @interface WaypointModifier
 */
export interface WaypointModifier {
  /**
   *
   * @type {WaypointModifierSymbol}
   * @memberof WaypointModifier
   */
  symbol: WaypointModifierSymbol
  /**
   * The name of the trait.
   * @type {string}
   * @memberof WaypointModifier
   */
  name: string
  /**
   * A description of the trait.
   * @type {string}
   * @memberof WaypointModifier
   */
  description: string
}

/**
 * The unique identifier of the modifier.
 * @export
 * @enum {string}
 */

export const WaypointModifierSymbol = {
  Stripped: 'STRIPPED',
  Unstable: 'UNSTABLE',
  RadiationLeak: 'RADIATION_LEAK',
  CriticalLimit: 'CRITICAL_LIMIT',
  CivilUnrest: 'CIVIL_UNREST',
} as const

export type WaypointModifierSymbol = (typeof WaypointModifierSymbol)[keyof typeof WaypointModifierSymbol]

/**
 * An orbital is another waypoint that orbits a parent waypoint.
 * @export
 * @interface WaypointOrbital
 */
export interface WaypointOrbital {
  /**
   * The symbol of the orbiting waypoint.
   * @type {string}
   * @memberof WaypointOrbital
   */
  symbol: string
}
/**
 *
 * @export
 * @interface WaypointTrait
 */
export interface WaypointTrait {
  /**
   *
   * @type {WaypointTraitSymbol}
   * @memberof WaypointTrait
   */
  symbol: WaypointTraitSymbol
  /**
   * The name of the trait.
   * @type {string}
   * @memberof WaypointTrait
   */
  name: string
  /**
   * A description of the trait.
   * @type {string}
   * @memberof WaypointTrait
   */
  description: string
}

/**
 * The unique identifier of the trait.
 * @export
 * @enum {string}
 */

export const WaypointTraitSymbol = {
  Uncharted: 'UNCHARTED',
  UnderConstruction: 'UNDER_CONSTRUCTION',
  Marketplace: 'MARKETPLACE',
  Shipyard: 'SHIPYARD',
  Outpost: 'OUTPOST',
  ScatteredSettlements: 'SCATTERED_SETTLEMENTS',
  SprawlingCities: 'SPRAWLING_CITIES',
  MegaStructures: 'MEGA_STRUCTURES',
  PirateBase: 'PIRATE_BASE',
  Overcrowded: 'OVERCROWDED',
  HighTech: 'HIGH_TECH',
  Corrupt: 'CORRUPT',
  Bureaucratic: 'BUREAUCRATIC',
  TradingHub: 'TRADING_HUB',
  Industrial: 'INDUSTRIAL',
  BlackMarket: 'BLACK_MARKET',
  ResearchFacility: 'RESEARCH_FACILITY',
  MilitaryBase: 'MILITARY_BASE',
  SurveillanceOutpost: 'SURVEILLANCE_OUTPOST',
  ExplorationOutpost: 'EXPLORATION_OUTPOST',
  MineralDeposits: 'MINERAL_DEPOSITS',
  CommonMetalDeposits: 'COMMON_METAL_DEPOSITS',
  PreciousMetalDeposits: 'PRECIOUS_METAL_DEPOSITS',
  RareMetalDeposits: 'RARE_METAL_DEPOSITS',
  MethanePools: 'METHANE_POOLS',
  IceCrystals: 'ICE_CRYSTALS',
  ExplosiveGases: 'EXPLOSIVE_GASES',
  StrongMagnetosphere: 'STRONG_MAGNETOSPHERE',
  VibrantAuroras: 'VIBRANT_AURORAS',
  SaltFlats: 'SALT_FLATS',
  Canyons: 'CANYONS',
  PerpetualDaylight: 'PERPETUAL_DAYLIGHT',
  PerpetualOvercast: 'PERPETUAL_OVERCAST',
  DrySeabeds: 'DRY_SEABEDS',
  MagmaSeas: 'MAGMA_SEAS',
  Supervolcanoes: 'SUPERVOLCANOES',
  AshClouds: 'ASH_CLOUDS',
  VastRuins: 'VAST_RUINS',
  MutatedFlora: 'MUTATED_FLORA',
  Terraformed: 'TERRAFORMED',
  ExtremeTemperatures: 'EXTREME_TEMPERATURES',
  ExtremePressure: 'EXTREME_PRESSURE',
  DiverseLife: 'DIVERSE_LIFE',
  ScarceLife: 'SCARCE_LIFE',
  Fossils: 'FOSSILS',
  WeakGravity: 'WEAK_GRAVITY',
  StrongGravity: 'STRONG_GRAVITY',
  CrushingGravity: 'CRUSHING_GRAVITY',
  ToxicAtmosphere: 'TOXIC_ATMOSPHERE',
  CorrosiveAtmosphere: 'CORROSIVE_ATMOSPHERE',
  BreathableAtmosphere: 'BREATHABLE_ATMOSPHERE',
  ThinAtmosphere: 'THIN_ATMOSPHERE',
  Jovian: 'JOVIAN',
  Rocky: 'ROCKY',
  Volcanic: 'VOLCANIC',
  Frozen: 'FROZEN',
  Swamp: 'SWAMP',
  Barren: 'BARREN',
  Temperate: 'TEMPERATE',
  Jungle: 'JUNGLE',
  Ocean: 'OCEAN',
  Radioactive: 'RADIOACTIVE',
  MicroGravityAnomalies: 'MICRO_GRAVITY_ANOMALIES',
  DebrisCluster: 'DEBRIS_CLUSTER',
  DeepCraters: 'DEEP_CRATERS',
  ShallowCraters: 'SHALLOW_CRATERS',
  UnstableComposition: 'UNSTABLE_COMPOSITION',
  HollowedInterior: 'HOLLOWED_INTERIOR',
  Stripped: 'STRIPPED',
} as const

export type WaypointTraitSymbol = (typeof WaypointTraitSymbol)[keyof typeof WaypointTraitSymbol]

/**
 * The type of waypoint.
 * @export
 * @enum {string}
 */

export const WaypointType = {
  Planet: 'PLANET',
  GasGiant: 'GAS_GIANT',
  Moon: 'MOON',
  OrbitalStation: 'ORBITAL_STATION',
  JumpGate: 'JUMP_GATE',
  AsteroidField: 'ASTEROID_FIELD',
  Asteroid: 'ASTEROID',
  EngineeredAsteroid: 'ENGINEERED_ASTEROID',
  AsteroidBase: 'ASTEROID_BASE',
  Nebula: 'NEBULA',
  DebrisField: 'DEBRIS_FIELD',
  GravityWell: 'GRAVITY_WELL',
  ArtificialGravityWell: 'ARTIFICIAL_GRAVITY_WELL',
  FuelStation: 'FUEL_STATION',
} as const

export type WaypointType = (typeof WaypointType)[keyof typeof WaypointType]

/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Fetch agent details.
     * @summary Get Public Agent
     * @param {string} agentSymbol The agent symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAgent: async (agentSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'agentSymbol' is not null or undefined
      assertParamExists('getAgent', 'agentSymbol', agentSymbol)
      const localVarPath = `/agents/{agentSymbol}`.replace(`{${'agentSymbol'}}`, encodeURIComponent(String(agentSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Fetch agents details.
     * @summary List Agents
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAgents: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/agents`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Fetch your agent\'s details.
     * @summary Get Agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyAgent: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/my/agent`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
  return {
    /**
     * Fetch agent details.
     * @summary Get Public Agent
     * @param {string} agentSymbol The agent symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAgent(
      agentSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyAgent200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAgent(agentSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['AgentsApi.getAgent']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Fetch agents details.
     * @summary List Agents
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAgents(
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAgents200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAgents(page, limit, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['AgentsApi.getAgents']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Fetch your agent\'s details.
     * @summary Get Agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyAgent(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyAgent200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyAgent(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['AgentsApi.getMyAgent']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AgentsApiFp(configuration)
  return {
    /**
     * Fetch agent details.
     * @summary Get Public Agent
     * @param {string} agentSymbol The agent symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAgent(agentSymbol: string, options?: any): AxiosPromise<GetMyAgent200Response> {
      return localVarFp.getAgent(agentSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Fetch agents details.
     * @summary List Agents
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAgents(page?: number, limit?: number, options?: any): AxiosPromise<GetAgents200Response> {
      return localVarFp.getAgents(page, limit, options).then((request) => request(axios, basePath))
    },
    /**
     * Fetch your agent\'s details.
     * @summary Get Agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyAgent(options?: any): AxiosPromise<GetMyAgent200Response> {
      return localVarFp.getMyAgent(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
  /**
   * Fetch agent details.
   * @summary Get Public Agent
   * @param {string} agentSymbol The agent symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  public getAgent(agentSymbol: string, options?: RawAxiosRequestConfig) {
    return AgentsApiFp(this.configuration)
      .getAgent(agentSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Fetch agents details.
   * @summary List Agents
   * @param {number} [page] What entry offset to request
   * @param {number} [limit] How many entries to return per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  public getAgents(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
    return AgentsApiFp(this.configuration)
      .getAgents(page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Fetch your agent\'s details.
   * @summary Get Agent
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentsApi
   */
  public getMyAgent(options?: RawAxiosRequestConfig) {
    return AgentsApiFp(this.configuration)
      .getMyAgent(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Accept a contract by ID.   You can only accept contracts that were offered to you, were not accepted yet, and whose deadlines has not passed yet.
     * @summary Accept Contract
     * @param {string} contractId The contract ID to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptContract: async (contractId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists('acceptContract', 'contractId', contractId)
      const localVarPath = `/my/contracts/{contractId}/accept`.replace(`{${'contractId'}}`, encodeURIComponent(String(contractId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deliver cargo to a contract.  In order to use this API, a ship must be at the delivery location (denoted in the delivery terms as `destinationSymbol` of a contract) and must have a number of units of a good required by this contract in its cargo.  Cargo that was delivered will be removed from the ship\'s cargo.
     * @summary Deliver Cargo to Contract
     * @param {string} contractId The ID of the contract.
     * @param {DeliverContractRequest} [deliverContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deliverContract: async (
      contractId: string,
      deliverContractRequest?: DeliverContractRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists('deliverContract', 'contractId', contractId)
      const localVarPath = `/my/contracts/{contractId}/deliver`.replace(`{${'contractId'}}`, encodeURIComponent(String(contractId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(deliverContractRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Fulfill a contract. Can only be used on contracts that have all of their delivery terms fulfilled.
     * @summary Fulfill Contract
     * @param {string} contractId The ID of the contract to fulfill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fulfillContract: async (contractId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists('fulfillContract', 'contractId', contractId)
      const localVarPath = `/my/contracts/{contractId}/fulfill`.replace(`{${'contractId'}}`, encodeURIComponent(String(contractId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the details of a contract by ID.
     * @summary Get Contract
     * @param {string} contractId The contract ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContract: async (contractId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contractId' is not null or undefined
      assertParamExists('getContract', 'contractId', contractId)
      const localVarPath = `/my/contracts/{contractId}`.replace(`{${'contractId'}}`, encodeURIComponent(String(contractId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return a paginated list of all your contracts.
     * @summary List Contracts
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContracts: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/my/contracts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
  return {
    /**
     * Accept a contract by ID.   You can only accept contracts that were offered to you, were not accepted yet, and whose deadlines has not passed yet.
     * @summary Accept Contract
     * @param {string} contractId The contract ID to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async acceptContract(
      contractId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.acceptContract(contractId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['ContractsApi.acceptContract']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deliver cargo to a contract.  In order to use this API, a ship must be at the delivery location (denoted in the delivery terms as `destinationSymbol` of a contract) and must have a number of units of a good required by this contract in its cargo.  Cargo that was delivered will be removed from the ship\'s cargo.
     * @summary Deliver Cargo to Contract
     * @param {string} contractId The ID of the contract.
     * @param {DeliverContractRequest} [deliverContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deliverContract(
      contractId: string,
      deliverContractRequest?: DeliverContractRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliverContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deliverContract(contractId, deliverContractRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['ContractsApi.deliverContract']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Fulfill a contract. Can only be used on contracts that have all of their delivery terms fulfilled.
     * @summary Fulfill Contract
     * @param {string} contractId The ID of the contract to fulfill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fulfillContract(
      contractId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FulfillContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fulfillContract(contractId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['ContractsApi.fulfillContract']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get the details of a contract by ID.
     * @summary Get Contract
     * @param {string} contractId The contract ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContract(
      contractId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContract(contractId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['ContractsApi.getContract']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return a paginated list of all your contracts.
     * @summary List Contracts
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContracts(
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContracts200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContracts(page, limit, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['ContractsApi.getContracts']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ContractsApiFp(configuration)
  return {
    /**
     * Accept a contract by ID.   You can only accept contracts that were offered to you, were not accepted yet, and whose deadlines has not passed yet.
     * @summary Accept Contract
     * @param {string} contractId The contract ID to accept.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptContract(contractId: string, options?: any): AxiosPromise<AcceptContract200Response> {
      return localVarFp.acceptContract(contractId, options).then((request) => request(axios, basePath))
    },
    /**
     * Deliver cargo to a contract.  In order to use this API, a ship must be at the delivery location (denoted in the delivery terms as `destinationSymbol` of a contract) and must have a number of units of a good required by this contract in its cargo.  Cargo that was delivered will be removed from the ship\'s cargo.
     * @summary Deliver Cargo to Contract
     * @param {string} contractId The ID of the contract.
     * @param {DeliverContractRequest} [deliverContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deliverContract(
      contractId: string,
      deliverContractRequest?: DeliverContractRequest,
      options?: any,
    ): AxiosPromise<DeliverContract200Response> {
      return localVarFp.deliverContract(contractId, deliverContractRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Fulfill a contract. Can only be used on contracts that have all of their delivery terms fulfilled.
     * @summary Fulfill Contract
     * @param {string} contractId The ID of the contract to fulfill.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fulfillContract(contractId: string, options?: any): AxiosPromise<FulfillContract200Response> {
      return localVarFp.fulfillContract(contractId, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the details of a contract by ID.
     * @summary Get Contract
     * @param {string} contractId The contract ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContract(contractId: string, options?: any): AxiosPromise<GetContract200Response> {
      return localVarFp.getContract(contractId, options).then((request) => request(axios, basePath))
    },
    /**
     * Return a paginated list of all your contracts.
     * @summary List Contracts
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContracts(page?: number, limit?: number, options?: any): AxiosPromise<GetContracts200Response> {
      return localVarFp.getContracts(page, limit, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
  /**
   * Accept a contract by ID.   You can only accept contracts that were offered to you, were not accepted yet, and whose deadlines has not passed yet.
   * @summary Accept Contract
   * @param {string} contractId The contract ID to accept.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public acceptContract(contractId: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .acceptContract(contractId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deliver cargo to a contract.  In order to use this API, a ship must be at the delivery location (denoted in the delivery terms as `destinationSymbol` of a contract) and must have a number of units of a good required by this contract in its cargo.  Cargo that was delivered will be removed from the ship\'s cargo.
   * @summary Deliver Cargo to Contract
   * @param {string} contractId The ID of the contract.
   * @param {DeliverContractRequest} [deliverContractRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public deliverContract(contractId: string, deliverContractRequest?: DeliverContractRequest, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .deliverContract(contractId, deliverContractRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Fulfill a contract. Can only be used on contracts that have all of their delivery terms fulfilled.
   * @summary Fulfill Contract
   * @param {string} contractId The ID of the contract to fulfill.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public fulfillContract(contractId: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .fulfillContract(contractId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the details of a contract by ID.
   * @summary Get Contract
   * @param {string} contractId The contract ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContract(contractId: string, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContract(contractId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return a paginated list of all your contracts.
   * @summary List Contracts
   * @param {number} [page] What entry offset to request
   * @param {number} [limit] How many entries to return per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractsApi
   */
  public getContracts(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
    return ContractsApiFp(this.configuration)
      .getContracts(page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Return the status of the game server. This also includes a few global elements, such as announcements, server reset dates and leaderboards.
     * @summary Get Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates a new agent and ties it to an account.  The agent symbol must consist of a 3-14 character string, and will be used to represent your agent. This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all uppercase characters.  This new agent will be tied to a starting faction of your choice, which determines your starting location, and will be granted an authorization token, a contract with their starting faction, a command ship that can fly across space with advanced capabilities, a small probe ship that can be used for reconnaissance, and 150,000 credits.  > #### Keep your token safe and secure > > Save your token during the alpha phase. There is no way to regenerate this token without starting a new agent. In the future you will be able to generate and manage your tokens from the SpaceTraders website.  If you are new to SpaceTraders, It is recommended to register with the COSMIC faction, a faction that is well connected to the rest of the universe. After registering, you should try our interactive [quickstart guide](https://docs.spacetraders.io/quickstart/new-game) which will walk you through basic API requests in just a few minutes.
     * @summary Register New Agent
     * @param {RegisterRequest} [registerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register: async (registerRequest?: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/register`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * Return the status of the game server. This also includes a few global elements, such as announcements, server reset dates and leaderboards.
     * @summary Get Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatus(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatus200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStatus']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Creates a new agent and ties it to an account.  The agent symbol must consist of a 3-14 character string, and will be used to represent your agent. This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all uppercase characters.  This new agent will be tied to a starting faction of your choice, which determines your starting location, and will be granted an authorization token, a contract with their starting faction, a command ship that can fly across space with advanced capabilities, a small probe ship that can be used for reconnaissance, and 150,000 credits.  > #### Keep your token safe and secure > > Save your token during the alpha phase. There is no way to regenerate this token without starting a new agent. In the future you will be able to generate and manage your tokens from the SpaceTraders website.  If you are new to SpaceTraders, It is recommended to register with the COSMIC faction, a faction that is well connected to the rest of the universe. After registering, you should try our interactive [quickstart guide](https://docs.spacetraders.io/quickstart/new-game) which will walk you through basic API requests in just a few minutes.
     * @summary Register New Agent
     * @param {RegisterRequest} [registerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async register(
      registerRequest?: RegisterRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Register201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['DefaultApi.register']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * Return the status of the game server. This also includes a few global elements, such as announcements, server reset dates and leaderboards.
     * @summary Get Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(options?: any): AxiosPromise<GetStatus200Response> {
      return localVarFp.getStatus(options).then((request) => request(axios, basePath))
    },
    /**
     * Creates a new agent and ties it to an account.  The agent symbol must consist of a 3-14 character string, and will be used to represent your agent. This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all uppercase characters.  This new agent will be tied to a starting faction of your choice, which determines your starting location, and will be granted an authorization token, a contract with their starting faction, a command ship that can fly across space with advanced capabilities, a small probe ship that can be used for reconnaissance, and 150,000 credits.  > #### Keep your token safe and secure > > Save your token during the alpha phase. There is no way to regenerate this token without starting a new agent. In the future you will be able to generate and manage your tokens from the SpaceTraders website.  If you are new to SpaceTraders, It is recommended to register with the COSMIC faction, a faction that is well connected to the rest of the universe. After registering, you should try our interactive [quickstart guide](https://docs.spacetraders.io/quickstart/new-game) which will walk you through basic API requests in just a few minutes.
     * @summary Register New Agent
     * @param {RegisterRequest} [registerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(registerRequest?: RegisterRequest, options?: any): AxiosPromise<Register201Response> {
      return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Return the status of the game server. This also includes a few global elements, such as announcements, server reset dates and leaderboards.
   * @summary Get Status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getStatus(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getStatus(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates a new agent and ties it to an account.  The agent symbol must consist of a 3-14 character string, and will be used to represent your agent. This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all uppercase characters.  This new agent will be tied to a starting faction of your choice, which determines your starting location, and will be granted an authorization token, a contract with their starting faction, a command ship that can fly across space with advanced capabilities, a small probe ship that can be used for reconnaissance, and 150,000 credits.  > #### Keep your token safe and secure > > Save your token during the alpha phase. There is no way to regenerate this token without starting a new agent. In the future you will be able to generate and manage your tokens from the SpaceTraders website.  If you are new to SpaceTraders, It is recommended to register with the COSMIC faction, a faction that is well connected to the rest of the universe. After registering, you should try our interactive [quickstart guide](https://docs.spacetraders.io/quickstart/new-game) which will walk you through basic API requests in just a few minutes.
   * @summary Register New Agent
   * @param {RegisterRequest} [registerRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public register(registerRequest?: RegisterRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .register(registerRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FactionsApi - axios parameter creator
 * @export
 */
export const FactionsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * View the details of a faction.
     * @summary Get Faction
     * @param {string} factionSymbol The faction symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFaction: async (factionSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'factionSymbol' is not null or undefined
      assertParamExists('getFaction', 'factionSymbol', factionSymbol)
      const localVarPath = `/factions/{factionSymbol}`.replace(`{${'factionSymbol'}}`, encodeURIComponent(String(factionSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return a paginated list of all the factions in the game.
     * @summary List Factions
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFactions: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/factions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FactionsApi - functional programming interface
 * @export
 */
export const FactionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FactionsApiAxiosParamCreator(configuration)
  return {
    /**
     * View the details of a faction.
     * @summary Get Faction
     * @param {string} factionSymbol The faction symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFaction(
      factionSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFaction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFaction(factionSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FactionsApi.getFaction']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return a paginated list of all the factions in the game.
     * @summary List Factions
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFactions(
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFactions200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFactions(page, limit, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FactionsApi.getFactions']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * FactionsApi - factory interface
 * @export
 */
export const FactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FactionsApiFp(configuration)
  return {
    /**
     * View the details of a faction.
     * @summary Get Faction
     * @param {string} factionSymbol The faction symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFaction(factionSymbol: string, options?: any): AxiosPromise<GetFaction200Response> {
      return localVarFp.getFaction(factionSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Return a paginated list of all the factions in the game.
     * @summary List Factions
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFactions(page?: number, limit?: number, options?: any): AxiosPromise<GetFactions200Response> {
      return localVarFp.getFactions(page, limit, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * FactionsApi - object-oriented interface
 * @export
 * @class FactionsApi
 * @extends {BaseAPI}
 */
export class FactionsApi extends BaseAPI {
  /**
   * View the details of a faction.
   * @summary Get Faction
   * @param {string} factionSymbol The faction symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionsApi
   */
  public getFaction(factionSymbol: string, options?: RawAxiosRequestConfig) {
    return FactionsApiFp(this.configuration)
      .getFaction(factionSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return a paginated list of all the factions in the game.
   * @summary List Factions
   * @param {number} [page] What entry offset to request
   * @param {number} [limit] How many entries to return per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FactionsApi
   */
  public getFactions(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
    return FactionsApiFp(this.configuration)
      .getFactions(page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FleetApi - axios parameter creator
 * @export
 */
export const FleetApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Command a ship to chart the waypoint at its current location.  Most waypoints in the universe are uncharted by default. These waypoints have their traits hidden until they have been charted by a ship.  Charting a waypoint will record your agent as the one who created the chart, and all other agents would also be able to see the waypoint\'s traits.
     * @summary Create Chart
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChart: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('createChart', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/chart`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Scan for nearby ships, retrieving information for all ships in range.  Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
     * @summary Scan Ships
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShipShipScan: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('createShipShipScan', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/scan/ships`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Scan for nearby systems, retrieving information on the systems\' distance from the ship and their waypoints. Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
     * @summary Scan Systems
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShipSystemScan: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('createShipSystemScan', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/scan/systems`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Scan for nearby waypoints, retrieving detailed information on each waypoint in range. Scanning uncharted waypoints will allow you to ignore their uncharted state and will list the waypoints\' traits.  Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
     * @summary Scan Waypoints
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShipWaypointScan: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('createShipWaypointScan', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/scan/waypoints`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create surveys on a waypoint that can be extracted such as asteroid fields. A survey focuses on specific types of deposits from the extracted location. When ships extract using this survey, they are guaranteed to procure a high amount of one of the goods in the survey.  In order to use a survey, send the entire survey details in the body of the extract request.  Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.  Your ship will enter a cooldown after surveying in which it is unable to perform certain actions. Surveys will eventually expire after a period of time or will be exhausted after being extracted several times based on the survey\'s size. Multiple ships can use the same survey for extraction.  A ship must have the `Surveyor` mount installed in order to use this function.
     * @summary Create Survey
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSurvey: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('createSurvey', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/survey`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Attempt to dock your ship at its current location. Docking will only succeed if your ship is capable of docking at the time of the request.  Docked ships can access elements in their current location, such as the market or a shipyard, but cannot do actions that require the ship to be above surface such as navigating or extracting.  The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
     * @summary Dock Ship
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dockShip: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('dockShip', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/dock`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Extract resources from a waypoint that can be extracted, such as asteroid fields, into your ship. Send an optional survey as the payload to target specific yields.  The ship must be in orbit to be able to extract and must have mining equipments installed that can extract goods, such as the `Gas Siphon` mount for gas-based goods or `Mining Laser` mount for ore-based goods.  The survey property is now deprecated. See the `extract/survey` endpoint for more details.
     * @summary Extract Resources
     * @param {string} shipSymbol The ship symbol.
     * @param {ExtractResourcesRequest} [extractResourcesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractResources: async (
      shipSymbol: string,
      extractResourcesRequest?: ExtractResourcesRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('extractResources', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/extract`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(extractResourcesRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Use a survey when extracting resources from a waypoint. This endpoint requires a survey as the payload, which allows your ship to extract specific yields.  Send the full survey object as the payload which will be validated according to the signature. If the signature is invalid, or any properties of the survey are changed, the request will fail.
     * @summary Extract Resources with Survey
     * @param {string} shipSymbol The ship symbol.
     * @param {Survey} [survey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractResourcesWithSurvey: async (shipSymbol: string, survey?: Survey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('extractResourcesWithSurvey', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/extract/survey`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(survey, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the mounts installed on a ship.
     * @summary Get Mounts
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMounts: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('getMounts', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/mounts`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the details of a ship under your agent\'s ownership.
     * @summary Get Ship
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyShip: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('getMyShip', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the cargo of a ship under your agent\'s ownership.
     * @summary Get Ship Cargo
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyShipCargo: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('getMyShipCargo', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/cargo`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return a paginated list of all of ships under your agent\'s ownership.
     * @summary List Ships
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyShips: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/my/ships`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve the details of your ship\'s reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.  Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.  Response returns a 204 status code (no-content) when the ship has no cooldown.
     * @summary Get Ship Cooldown
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShipCooldown: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('getShipCooldown', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/cooldown`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the current nav status of a ship.
     * @summary Get Ship Nav
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShipNav: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('getShipNav', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/nav`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Install a mount on a ship.  In order to install a mount, the ship must be docked and located in a waypoint that has a `Shipyard` trait. The ship also must have the mount to install in its cargo hold.  An installation fee will be deduced by the Shipyard for installing the mount on the ship.
     * @summary Install Mount
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {InstallMountRequest} [installMountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installMount: async (
      shipSymbol: string,
      installMountRequest?: InstallMountRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('installMount', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/mounts/install`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(installMountRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Jettison cargo from your ship\'s cargo hold.
     * @summary Jettison Cargo
     * @param {string} shipSymbol The ship symbol.
     * @param {JettisonRequest} [jettisonRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    jettison: async (shipSymbol: string, jettisonRequest?: JettisonRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('jettison', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/jettison`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(jettisonRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Jump your ship instantly to a target connected waypoint. The ship must be in orbit to execute a jump.  A unit of antimatter is purchased and consumed from the market when jumping. The price of antimatter is determined by the market and is subject to change. A ship can only jump to connected waypoints
     * @summary Jump Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {JumpShipRequest} [jumpShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    jumpShip: async (shipSymbol: string, jumpShipRequest?: JumpShipRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('jumpShip', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/jump`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(jumpShipRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Navigate to a target destination. The ship must be in orbit to use this function. The destination waypoint must be within the same system as the ship\'s current location. Navigating will consume the necessary fuel from the ship\'s manifest based on the distance to the target waypoint.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.  To travel between systems, see the ship\'s Warp or Jump actions.
     * @summary Navigate Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {NavigateShipRequest} [navigateShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    navigateShip: async (
      shipSymbol: string,
      navigateShipRequest?: NavigateShipRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('navigateShip', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/navigate`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(navigateShipRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Negotiate a new contract with the HQ.  In order to negotiate a new contract, an agent must not have ongoing or offered contracts over the allowed maximum amount. Currently the maximum contracts an agent can have at a time is 1.  Once a contract is negotiated, it is added to the list of contracts offered to the agent, which the agent can then accept.   The ship must be present at any waypoint with a faction present to negotiate a contract with that faction.
     * @summary Negotiate Contract
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    negotiateContract: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('negotiateContract', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/negotiate/contract`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Attempt to move your ship into orbit at its current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.  Orbiting ships are able to do actions that require the ship to be above surface such as navigating or extracting, but cannot access elements in their current waypoint, such as the market or a shipyard.  The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
     * @summary Orbit Ship
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    orbitShip: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('orbitShip', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/orbit`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the nav configuration of a ship.  Currently only supports configuring the Flight Mode of the ship, which affects its speed and fuel consumption.
     * @summary Patch Ship Nav
     * @param {string} shipSymbol The ship symbol.
     * @param {PatchShipNavRequest} [patchShipNavRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchShipNav: async (
      shipSymbol: string,
      patchShipNavRequest?: PatchShipNavRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('patchShipNav', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/nav`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(patchShipNavRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Purchase cargo from a market.  The ship must be docked in a waypoint that has `Marketplace` trait, and the market must be selling a good to be able to purchase it.  The maximum amount of units of a good that can be purchased in each transaction are denoted by the `tradeVolume` value of the good, which can be viewed by using the Get Market action.  Purchased goods are added to the ship\'s cargo hold.
     * @summary Purchase Cargo
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {PurchaseCargoRequest} [purchaseCargoRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseCargo: async (
      shipSymbol: string,
      purchaseCargoRequest?: PurchaseCargoRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('purchaseCargo', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/purchase`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(purchaseCargoRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Purchase a ship from a Shipyard. In order to use this function, a ship under your agent\'s ownership must be in a waypoint that has the `Shipyard` trait, and the Shipyard must sell the type of the desired ship.  Shipyards typically offer ship types, which are predefined templates of ships that have dedicated roles. A template comes with a preset of an engine, a reactor, and a frame. It may also include a few modules and mounts.
     * @summary Purchase Ship
     * @param {PurchaseShipRequest} [purchaseShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseShip: async (purchaseShipRequest?: PurchaseShipRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/my/ships`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(purchaseShipRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Refuel your ship by buying fuel from the local market.  Requires the ship to be docked in a waypoint that has the `Marketplace` trait, and the market must be selling fuel in order to refuel.  Each fuel bought from the market replenishes 100 units in your ship\'s fuel.  Ships will always be refuel to their frame\'s maximum fuel capacity when using this action.
     * @summary Refuel Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {RefuelShipRequest} [refuelShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refuelShip: async (
      shipSymbol: string,
      refuelShipRequest?: RefuelShipRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('refuelShip', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/refuel`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(refuelShipRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Remove a mount from a ship.  The ship must be docked in a waypoint that has the `Shipyard` trait, and must have the desired mount that it wish to remove installed.  A removal fee will be deduced from the agent by the Shipyard.
     * @summary Remove Mount
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {RemoveMountRequest} [removeMountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMount: async (
      shipSymbol: string,
      removeMountRequest?: RemoveMountRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('removeMount', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/mounts/remove`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(removeMountRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Sell cargo in your ship to a market that trades this cargo. The ship must be docked in a waypoint that has the `Marketplace` trait in order to use this function.
     * @summary Sell Cargo
     * @param {string} shipSymbol Symbol of a ship.
     * @param {SellCargoRequest} [sellCargoRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sellCargo: async (
      shipSymbol: string,
      sellCargoRequest?: SellCargoRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('sellCargo', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/sell`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(sellCargoRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request. In order to be able to refine, a ship must have goods that can be refined and have installed a `Refinery` module that can refine it.  When refining, 30 basic goods will be converted into 10 processed goods.
     * @summary Ship Refine
     * @param {string} shipSymbol The symbol of the ship.
     * @param {ShipRefineRequest} [shipRefineRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shipRefine: async (
      shipSymbol: string,
      shipRefineRequest?: ShipRefineRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('shipRefine', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/refine`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(shipRefineRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Siphon gases, such as hydrocarbon, from gas giants.  The ship must be in orbit to be able to siphon and must have siphon mounts and a gas processor installed.
     * @summary Siphon Resources
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    siphonResources: async (shipSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('siphonResources', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/siphon`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Transfer cargo between ships.  The receiving ship must be in the same waypoint as the transferring ship, and it must able to hold the additional cargo after the transfer is complete. Both ships also must be in the same state, either both are docked or both are orbiting.  The response body\'s cargo shows the cargo of the transferring ship after the transfer is complete.
     * @summary Transfer Cargo
     * @param {string} shipSymbol The transferring ship\&#39;s symbol.
     * @param {TransferCargoRequest} [transferCargoRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferCargo: async (
      shipSymbol: string,
      transferCargoRequest?: TransferCargoRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('transferCargo', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/transfer`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(transferCargoRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Warp your ship to a target destination in another system. The ship must be in orbit to use this function and must have the `Warp Drive` module installed. Warping will consume the necessary fuel from the ship\'s manifest.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at its destination.
     * @summary Warp Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {NavigateShipRequest} [navigateShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    warpShip: async (
      shipSymbol: string,
      navigateShipRequest?: NavigateShipRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipSymbol' is not null or undefined
      assertParamExists('warpShip', 'shipSymbol', shipSymbol)
      const localVarPath = `/my/ships/{shipSymbol}/warp`.replace(`{${'shipSymbol'}}`, encodeURIComponent(String(shipSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(navigateShipRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FleetApi - functional programming interface
 * @export
 */
export const FleetApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FleetApiAxiosParamCreator(configuration)
  return {
    /**
     * Command a ship to chart the waypoint at its current location.  Most waypoints in the universe are uncharted by default. These waypoints have their traits hidden until they have been charted by a ship.  Charting a waypoint will record your agent as the one who created the chart, and all other agents would also be able to see the waypoint\'s traits.
     * @summary Create Chart
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createChart(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateChart201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createChart(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.createChart']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Scan for nearby ships, retrieving information for all ships in range.  Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
     * @summary Scan Ships
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createShipShipScan(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateShipShipScan201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createShipShipScan(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.createShipShipScan']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Scan for nearby systems, retrieving information on the systems\' distance from the ship and their waypoints. Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
     * @summary Scan Systems
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createShipSystemScan(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateShipSystemScan201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createShipSystemScan(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.createShipSystemScan']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Scan for nearby waypoints, retrieving detailed information on each waypoint in range. Scanning uncharted waypoints will allow you to ignore their uncharted state and will list the waypoints\' traits.  Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
     * @summary Scan Waypoints
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createShipWaypointScan(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateShipWaypointScan201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createShipWaypointScan(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.createShipWaypointScan']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create surveys on a waypoint that can be extracted such as asteroid fields. A survey focuses on specific types of deposits from the extracted location. When ships extract using this survey, they are guaranteed to procure a high amount of one of the goods in the survey.  In order to use a survey, send the entire survey details in the body of the extract request.  Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.  Your ship will enter a cooldown after surveying in which it is unable to perform certain actions. Surveys will eventually expire after a period of time or will be exhausted after being extracted several times based on the survey\'s size. Multiple ships can use the same survey for extraction.  A ship must have the `Surveyor` mount installed in order to use this function.
     * @summary Create Survey
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSurvey(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSurvey201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSurvey(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.createSurvey']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Attempt to dock your ship at its current location. Docking will only succeed if your ship is capable of docking at the time of the request.  Docked ships can access elements in their current location, such as the market or a shipyard, but cannot do actions that require the ship to be above surface such as navigating or extracting.  The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
     * @summary Dock Ship
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dockShip(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DockShip200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dockShip(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.dockShip']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Extract resources from a waypoint that can be extracted, such as asteroid fields, into your ship. Send an optional survey as the payload to target specific yields.  The ship must be in orbit to be able to extract and must have mining equipments installed that can extract goods, such as the `Gas Siphon` mount for gas-based goods or `Mining Laser` mount for ore-based goods.  The survey property is now deprecated. See the `extract/survey` endpoint for more details.
     * @summary Extract Resources
     * @param {string} shipSymbol The ship symbol.
     * @param {ExtractResourcesRequest} [extractResourcesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async extractResources(
      shipSymbol: string,
      extractResourcesRequest?: ExtractResourcesRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtractResources201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.extractResources(shipSymbol, extractResourcesRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.extractResources']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Use a survey when extracting resources from a waypoint. This endpoint requires a survey as the payload, which allows your ship to extract specific yields.  Send the full survey object as the payload which will be validated according to the signature. If the signature is invalid, or any properties of the survey are changed, the request will fail.
     * @summary Extract Resources with Survey
     * @param {string} shipSymbol The ship symbol.
     * @param {Survey} [survey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async extractResourcesWithSurvey(
      shipSymbol: string,
      survey?: Survey,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtractResources201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.extractResourcesWithSurvey(shipSymbol, survey, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.extractResourcesWithSurvey']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get the mounts installed on a ship.
     * @summary Get Mounts
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMounts(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMounts200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMounts(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.getMounts']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieve the details of a ship under your agent\'s ownership.
     * @summary Get Ship
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyShip(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyShip200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyShip(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.getMyShip']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieve the cargo of a ship under your agent\'s ownership.
     * @summary Get Ship Cargo
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyShipCargo(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyShipCargo200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyShipCargo(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.getMyShipCargo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return a paginated list of all of ships under your agent\'s ownership.
     * @summary List Ships
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyShips(
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyShips200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyShips(page, limit, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.getMyShips']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieve the details of your ship\'s reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.  Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.  Response returns a 204 status code (no-content) when the ship has no cooldown.
     * @summary Get Ship Cooldown
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShipCooldown(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShipCooldown200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShipCooldown(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.getShipCooldown']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get the current nav status of a ship.
     * @summary Get Ship Nav
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShipNav(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShipNav200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShipNav(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.getShipNav']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Install a mount on a ship.  In order to install a mount, the ship must be docked and located in a waypoint that has a `Shipyard` trait. The ship also must have the mount to install in its cargo hold.  An installation fee will be deduced by the Shipyard for installing the mount on the ship.
     * @summary Install Mount
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {InstallMountRequest} [installMountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async installMount(
      shipSymbol: string,
      installMountRequest?: InstallMountRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstallMount201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.installMount(shipSymbol, installMountRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.installMount']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Jettison cargo from your ship\'s cargo hold.
     * @summary Jettison Cargo
     * @param {string} shipSymbol The ship symbol.
     * @param {JettisonRequest} [jettisonRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async jettison(
      shipSymbol: string,
      jettisonRequest?: JettisonRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Jettison200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.jettison(shipSymbol, jettisonRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.jettison']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Jump your ship instantly to a target connected waypoint. The ship must be in orbit to execute a jump.  A unit of antimatter is purchased and consumed from the market when jumping. The price of antimatter is determined by the market and is subject to change. A ship can only jump to connected waypoints
     * @summary Jump Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {JumpShipRequest} [jumpShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async jumpShip(
      shipSymbol: string,
      jumpShipRequest?: JumpShipRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JumpShip200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.jumpShip(shipSymbol, jumpShipRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.jumpShip']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Navigate to a target destination. The ship must be in orbit to use this function. The destination waypoint must be within the same system as the ship\'s current location. Navigating will consume the necessary fuel from the ship\'s manifest based on the distance to the target waypoint.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.  To travel between systems, see the ship\'s Warp or Jump actions.
     * @summary Navigate Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {NavigateShipRequest} [navigateShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async navigateShip(
      shipSymbol: string,
      navigateShipRequest?: NavigateShipRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NavigateShip200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.navigateShip(shipSymbol, navigateShipRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.navigateShip']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Negotiate a new contract with the HQ.  In order to negotiate a new contract, an agent must not have ongoing or offered contracts over the allowed maximum amount. Currently the maximum contracts an agent can have at a time is 1.  Once a contract is negotiated, it is added to the list of contracts offered to the agent, which the agent can then accept.   The ship must be present at any waypoint with a faction present to negotiate a contract with that faction.
     * @summary Negotiate Contract
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async negotiateContract(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NegotiateContract200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.negotiateContract(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.negotiateContract']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Attempt to move your ship into orbit at its current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.  Orbiting ships are able to do actions that require the ship to be above surface such as navigating or extracting, but cannot access elements in their current waypoint, such as the market or a shipyard.  The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
     * @summary Orbit Ship
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async orbitShip(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrbitShip200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.orbitShip(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.orbitShip']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Update the nav configuration of a ship.  Currently only supports configuring the Flight Mode of the ship, which affects its speed and fuel consumption.
     * @summary Patch Ship Nav
     * @param {string} shipSymbol The ship symbol.
     * @param {PatchShipNavRequest} [patchShipNavRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchShipNav(
      shipSymbol: string,
      patchShipNavRequest?: PatchShipNavRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShipNav200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchShipNav(shipSymbol, patchShipNavRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.patchShipNav']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Purchase cargo from a market.  The ship must be docked in a waypoint that has `Marketplace` trait, and the market must be selling a good to be able to purchase it.  The maximum amount of units of a good that can be purchased in each transaction are denoted by the `tradeVolume` value of the good, which can be viewed by using the Get Market action.  Purchased goods are added to the ship\'s cargo hold.
     * @summary Purchase Cargo
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {PurchaseCargoRequest} [purchaseCargoRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async purchaseCargo(
      shipSymbol: string,
      purchaseCargoRequest?: PurchaseCargoRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchaseCargo201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseCargo(shipSymbol, purchaseCargoRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.purchaseCargo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Purchase a ship from a Shipyard. In order to use this function, a ship under your agent\'s ownership must be in a waypoint that has the `Shipyard` trait, and the Shipyard must sell the type of the desired ship.  Shipyards typically offer ship types, which are predefined templates of ships that have dedicated roles. A template comes with a preset of an engine, a reactor, and a frame. It may also include a few modules and mounts.
     * @summary Purchase Ship
     * @param {PurchaseShipRequest} [purchaseShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async purchaseShip(
      purchaseShipRequest?: PurchaseShipRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchaseShip201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseShip(purchaseShipRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.purchaseShip']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Refuel your ship by buying fuel from the local market.  Requires the ship to be docked in a waypoint that has the `Marketplace` trait, and the market must be selling fuel in order to refuel.  Each fuel bought from the market replenishes 100 units in your ship\'s fuel.  Ships will always be refuel to their frame\'s maximum fuel capacity when using this action.
     * @summary Refuel Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {RefuelShipRequest} [refuelShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refuelShip(
      shipSymbol: string,
      refuelShipRequest?: RefuelShipRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefuelShip200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refuelShip(shipSymbol, refuelShipRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.refuelShip']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Remove a mount from a ship.  The ship must be docked in a waypoint that has the `Shipyard` trait, and must have the desired mount that it wish to remove installed.  A removal fee will be deduced from the agent by the Shipyard.
     * @summary Remove Mount
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {RemoveMountRequest} [removeMountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeMount(
      shipSymbol: string,
      removeMountRequest?: RemoveMountRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveMount201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeMount(shipSymbol, removeMountRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.removeMount']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Sell cargo in your ship to a market that trades this cargo. The ship must be docked in a waypoint that has the `Marketplace` trait in order to use this function.
     * @summary Sell Cargo
     * @param {string} shipSymbol Symbol of a ship.
     * @param {SellCargoRequest} [sellCargoRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sellCargo(
      shipSymbol: string,
      sellCargoRequest?: SellCargoRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SellCargo201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sellCargo(shipSymbol, sellCargoRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.sellCargo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request. In order to be able to refine, a ship must have goods that can be refined and have installed a `Refinery` module that can refine it.  When refining, 30 basic goods will be converted into 10 processed goods.
     * @summary Ship Refine
     * @param {string} shipSymbol The symbol of the ship.
     * @param {ShipRefineRequest} [shipRefineRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async shipRefine(
      shipSymbol: string,
      shipRefineRequest?: ShipRefineRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipRefine201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.shipRefine(shipSymbol, shipRefineRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.shipRefine']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Siphon gases, such as hydrocarbon, from gas giants.  The ship must be in orbit to be able to siphon and must have siphon mounts and a gas processor installed.
     * @summary Siphon Resources
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async siphonResources(
      shipSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiphonResources201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.siphonResources(shipSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.siphonResources']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Transfer cargo between ships.  The receiving ship must be in the same waypoint as the transferring ship, and it must able to hold the additional cargo after the transfer is complete. Both ships also must be in the same state, either both are docked or both are orbiting.  The response body\'s cargo shows the cargo of the transferring ship after the transfer is complete.
     * @summary Transfer Cargo
     * @param {string} shipSymbol The transferring ship\&#39;s symbol.
     * @param {TransferCargoRequest} [transferCargoRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transferCargo(
      shipSymbol: string,
      transferCargoRequest?: TransferCargoRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferCargo200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transferCargo(shipSymbol, transferCargoRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.transferCargo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Warp your ship to a target destination in another system. The ship must be in orbit to use this function and must have the `Warp Drive` module installed. Warping will consume the necessary fuel from the ship\'s manifest.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at its destination.
     * @summary Warp Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {NavigateShipRequest} [navigateShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async warpShip(
      shipSymbol: string,
      navigateShipRequest?: NavigateShipRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NavigateShip200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.warpShip(shipSymbol, navigateShipRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['FleetApi.warpShip']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * FleetApi - factory interface
 * @export
 */
export const FleetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FleetApiFp(configuration)
  return {
    /**
     * Command a ship to chart the waypoint at its current location.  Most waypoints in the universe are uncharted by default. These waypoints have their traits hidden until they have been charted by a ship.  Charting a waypoint will record your agent as the one who created the chart, and all other agents would also be able to see the waypoint\'s traits.
     * @summary Create Chart
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChart(shipSymbol: string, options?: any): AxiosPromise<CreateChart201Response> {
      return localVarFp.createChart(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Scan for nearby ships, retrieving information for all ships in range.  Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
     * @summary Scan Ships
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShipShipScan(shipSymbol: string, options?: any): AxiosPromise<CreateShipShipScan201Response> {
      return localVarFp.createShipShipScan(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Scan for nearby systems, retrieving information on the systems\' distance from the ship and their waypoints. Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
     * @summary Scan Systems
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShipSystemScan(shipSymbol: string, options?: any): AxiosPromise<CreateShipSystemScan201Response> {
      return localVarFp.createShipSystemScan(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Scan for nearby waypoints, retrieving detailed information on each waypoint in range. Scanning uncharted waypoints will allow you to ignore their uncharted state and will list the waypoints\' traits.  Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
     * @summary Scan Waypoints
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShipWaypointScan(shipSymbol: string, options?: any): AxiosPromise<CreateShipWaypointScan201Response> {
      return localVarFp.createShipWaypointScan(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Create surveys on a waypoint that can be extracted such as asteroid fields. A survey focuses on specific types of deposits from the extracted location. When ships extract using this survey, they are guaranteed to procure a high amount of one of the goods in the survey.  In order to use a survey, send the entire survey details in the body of the extract request.  Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.  Your ship will enter a cooldown after surveying in which it is unable to perform certain actions. Surveys will eventually expire after a period of time or will be exhausted after being extracted several times based on the survey\'s size. Multiple ships can use the same survey for extraction.  A ship must have the `Surveyor` mount installed in order to use this function.
     * @summary Create Survey
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSurvey(shipSymbol: string, options?: any): AxiosPromise<CreateSurvey201Response> {
      return localVarFp.createSurvey(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Attempt to dock your ship at its current location. Docking will only succeed if your ship is capable of docking at the time of the request.  Docked ships can access elements in their current location, such as the market or a shipyard, but cannot do actions that require the ship to be above surface such as navigating or extracting.  The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
     * @summary Dock Ship
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dockShip(shipSymbol: string, options?: any): AxiosPromise<DockShip200Response> {
      return localVarFp.dockShip(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Extract resources from a waypoint that can be extracted, such as asteroid fields, into your ship. Send an optional survey as the payload to target specific yields.  The ship must be in orbit to be able to extract and must have mining equipments installed that can extract goods, such as the `Gas Siphon` mount for gas-based goods or `Mining Laser` mount for ore-based goods.  The survey property is now deprecated. See the `extract/survey` endpoint for more details.
     * @summary Extract Resources
     * @param {string} shipSymbol The ship symbol.
     * @param {ExtractResourcesRequest} [extractResourcesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractResources(
      shipSymbol: string,
      extractResourcesRequest?: ExtractResourcesRequest,
      options?: any,
    ): AxiosPromise<ExtractResources201Response> {
      return localVarFp.extractResources(shipSymbol, extractResourcesRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Use a survey when extracting resources from a waypoint. This endpoint requires a survey as the payload, which allows your ship to extract specific yields.  Send the full survey object as the payload which will be validated according to the signature. If the signature is invalid, or any properties of the survey are changed, the request will fail.
     * @summary Extract Resources with Survey
     * @param {string} shipSymbol The ship symbol.
     * @param {Survey} [survey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extractResourcesWithSurvey(shipSymbol: string, survey?: Survey, options?: any): AxiosPromise<ExtractResources201Response> {
      return localVarFp.extractResourcesWithSurvey(shipSymbol, survey, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the mounts installed on a ship.
     * @summary Get Mounts
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMounts(shipSymbol: string, options?: any): AxiosPromise<GetMounts200Response> {
      return localVarFp.getMounts(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the details of a ship under your agent\'s ownership.
     * @summary Get Ship
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyShip(shipSymbol: string, options?: any): AxiosPromise<GetMyShip200Response> {
      return localVarFp.getMyShip(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the cargo of a ship under your agent\'s ownership.
     * @summary Get Ship Cargo
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyShipCargo(shipSymbol: string, options?: any): AxiosPromise<GetMyShipCargo200Response> {
      return localVarFp.getMyShipCargo(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Return a paginated list of all of ships under your agent\'s ownership.
     * @summary List Ships
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyShips(page?: number, limit?: number, options?: any): AxiosPromise<GetMyShips200Response> {
      return localVarFp.getMyShips(page, limit, options).then((request) => request(axios, basePath))
    },
    /**
     * Retrieve the details of your ship\'s reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.  Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.  Response returns a 204 status code (no-content) when the ship has no cooldown.
     * @summary Get Ship Cooldown
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShipCooldown(shipSymbol: string, options?: any): AxiosPromise<GetShipCooldown200Response> {
      return localVarFp.getShipCooldown(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the current nav status of a ship.
     * @summary Get Ship Nav
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShipNav(shipSymbol: string, options?: any): AxiosPromise<GetShipNav200Response> {
      return localVarFp.getShipNav(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Install a mount on a ship.  In order to install a mount, the ship must be docked and located in a waypoint that has a `Shipyard` trait. The ship also must have the mount to install in its cargo hold.  An installation fee will be deduced by the Shipyard for installing the mount on the ship.
     * @summary Install Mount
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {InstallMountRequest} [installMountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installMount(shipSymbol: string, installMountRequest?: InstallMountRequest, options?: any): AxiosPromise<InstallMount201Response> {
      return localVarFp.installMount(shipSymbol, installMountRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Jettison cargo from your ship\'s cargo hold.
     * @summary Jettison Cargo
     * @param {string} shipSymbol The ship symbol.
     * @param {JettisonRequest} [jettisonRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    jettison(shipSymbol: string, jettisonRequest?: JettisonRequest, options?: any): AxiosPromise<Jettison200Response> {
      return localVarFp.jettison(shipSymbol, jettisonRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Jump your ship instantly to a target connected waypoint. The ship must be in orbit to execute a jump.  A unit of antimatter is purchased and consumed from the market when jumping. The price of antimatter is determined by the market and is subject to change. A ship can only jump to connected waypoints
     * @summary Jump Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {JumpShipRequest} [jumpShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    jumpShip(shipSymbol: string, jumpShipRequest?: JumpShipRequest, options?: any): AxiosPromise<JumpShip200Response> {
      return localVarFp.jumpShip(shipSymbol, jumpShipRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Navigate to a target destination. The ship must be in orbit to use this function. The destination waypoint must be within the same system as the ship\'s current location. Navigating will consume the necessary fuel from the ship\'s manifest based on the distance to the target waypoint.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.  To travel between systems, see the ship\'s Warp or Jump actions.
     * @summary Navigate Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {NavigateShipRequest} [navigateShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    navigateShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: any): AxiosPromise<NavigateShip200Response> {
      return localVarFp.navigateShip(shipSymbol, navigateShipRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Negotiate a new contract with the HQ.  In order to negotiate a new contract, an agent must not have ongoing or offered contracts over the allowed maximum amount. Currently the maximum contracts an agent can have at a time is 1.  Once a contract is negotiated, it is added to the list of contracts offered to the agent, which the agent can then accept.   The ship must be present at any waypoint with a faction present to negotiate a contract with that faction.
     * @summary Negotiate Contract
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    negotiateContract(shipSymbol: string, options?: any): AxiosPromise<NegotiateContract200Response> {
      return localVarFp.negotiateContract(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Attempt to move your ship into orbit at its current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.  Orbiting ships are able to do actions that require the ship to be above surface such as navigating or extracting, but cannot access elements in their current waypoint, such as the market or a shipyard.  The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
     * @summary Orbit Ship
     * @param {string} shipSymbol The symbol of the ship.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    orbitShip(shipSymbol: string, options?: any): AxiosPromise<OrbitShip200Response> {
      return localVarFp.orbitShip(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Update the nav configuration of a ship.  Currently only supports configuring the Flight Mode of the ship, which affects its speed and fuel consumption.
     * @summary Patch Ship Nav
     * @param {string} shipSymbol The ship symbol.
     * @param {PatchShipNavRequest} [patchShipNavRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchShipNav(shipSymbol: string, patchShipNavRequest?: PatchShipNavRequest, options?: any): AxiosPromise<GetShipNav200Response> {
      return localVarFp.patchShipNav(shipSymbol, patchShipNavRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Purchase cargo from a market.  The ship must be docked in a waypoint that has `Marketplace` trait, and the market must be selling a good to be able to purchase it.  The maximum amount of units of a good that can be purchased in each transaction are denoted by the `tradeVolume` value of the good, which can be viewed by using the Get Market action.  Purchased goods are added to the ship\'s cargo hold.
     * @summary Purchase Cargo
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {PurchaseCargoRequest} [purchaseCargoRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseCargo(shipSymbol: string, purchaseCargoRequest?: PurchaseCargoRequest, options?: any): AxiosPromise<PurchaseCargo201Response> {
      return localVarFp.purchaseCargo(shipSymbol, purchaseCargoRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Purchase a ship from a Shipyard. In order to use this function, a ship under your agent\'s ownership must be in a waypoint that has the `Shipyard` trait, and the Shipyard must sell the type of the desired ship.  Shipyards typically offer ship types, which are predefined templates of ships that have dedicated roles. A template comes with a preset of an engine, a reactor, and a frame. It may also include a few modules and mounts.
     * @summary Purchase Ship
     * @param {PurchaseShipRequest} [purchaseShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseShip(purchaseShipRequest?: PurchaseShipRequest, options?: any): AxiosPromise<PurchaseShip201Response> {
      return localVarFp.purchaseShip(purchaseShipRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Refuel your ship by buying fuel from the local market.  Requires the ship to be docked in a waypoint that has the `Marketplace` trait, and the market must be selling fuel in order to refuel.  Each fuel bought from the market replenishes 100 units in your ship\'s fuel.  Ships will always be refuel to their frame\'s maximum fuel capacity when using this action.
     * @summary Refuel Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {RefuelShipRequest} [refuelShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refuelShip(shipSymbol: string, refuelShipRequest?: RefuelShipRequest, options?: any): AxiosPromise<RefuelShip200Response> {
      return localVarFp.refuelShip(shipSymbol, refuelShipRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Remove a mount from a ship.  The ship must be docked in a waypoint that has the `Shipyard` trait, and must have the desired mount that it wish to remove installed.  A removal fee will be deduced from the agent by the Shipyard.
     * @summary Remove Mount
     * @param {string} shipSymbol The ship\&#39;s symbol.
     * @param {RemoveMountRequest} [removeMountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMount(shipSymbol: string, removeMountRequest?: RemoveMountRequest, options?: any): AxiosPromise<RemoveMount201Response> {
      return localVarFp.removeMount(shipSymbol, removeMountRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Sell cargo in your ship to a market that trades this cargo. The ship must be docked in a waypoint that has the `Marketplace` trait in order to use this function.
     * @summary Sell Cargo
     * @param {string} shipSymbol Symbol of a ship.
     * @param {SellCargoRequest} [sellCargoRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sellCargo(shipSymbol: string, sellCargoRequest?: SellCargoRequest, options?: any): AxiosPromise<SellCargo201Response> {
      return localVarFp.sellCargo(shipSymbol, sellCargoRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request. In order to be able to refine, a ship must have goods that can be refined and have installed a `Refinery` module that can refine it.  When refining, 30 basic goods will be converted into 10 processed goods.
     * @summary Ship Refine
     * @param {string} shipSymbol The symbol of the ship.
     * @param {ShipRefineRequest} [shipRefineRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shipRefine(shipSymbol: string, shipRefineRequest?: ShipRefineRequest, options?: any): AxiosPromise<ShipRefine201Response> {
      return localVarFp.shipRefine(shipSymbol, shipRefineRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Siphon gases, such as hydrocarbon, from gas giants.  The ship must be in orbit to be able to siphon and must have siphon mounts and a gas processor installed.
     * @summary Siphon Resources
     * @param {string} shipSymbol The ship symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    siphonResources(shipSymbol: string, options?: any): AxiosPromise<SiphonResources201Response> {
      return localVarFp.siphonResources(shipSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Transfer cargo between ships.  The receiving ship must be in the same waypoint as the transferring ship, and it must able to hold the additional cargo after the transfer is complete. Both ships also must be in the same state, either both are docked or both are orbiting.  The response body\'s cargo shows the cargo of the transferring ship after the transfer is complete.
     * @summary Transfer Cargo
     * @param {string} shipSymbol The transferring ship\&#39;s symbol.
     * @param {TransferCargoRequest} [transferCargoRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferCargo(shipSymbol: string, transferCargoRequest?: TransferCargoRequest, options?: any): AxiosPromise<TransferCargo200Response> {
      return localVarFp.transferCargo(shipSymbol, transferCargoRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Warp your ship to a target destination in another system. The ship must be in orbit to use this function and must have the `Warp Drive` module installed. Warping will consume the necessary fuel from the ship\'s manifest.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at its destination.
     * @summary Warp Ship
     * @param {string} shipSymbol The ship symbol.
     * @param {NavigateShipRequest} [navigateShipRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    warpShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: any): AxiosPromise<NavigateShip200Response> {
      return localVarFp.warpShip(shipSymbol, navigateShipRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * FleetApi - object-oriented interface
 * @export
 * @class FleetApi
 * @extends {BaseAPI}
 */
export class FleetApi extends BaseAPI {
  /**
   * Command a ship to chart the waypoint at its current location.  Most waypoints in the universe are uncharted by default. These waypoints have their traits hidden until they have been charted by a ship.  Charting a waypoint will record your agent as the one who created the chart, and all other agents would also be able to see the waypoint\'s traits.
   * @summary Create Chart
   * @param {string} shipSymbol The symbol of the ship.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public createChart(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .createChart(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Scan for nearby ships, retrieving information for all ships in range.  Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
   * @summary Scan Ships
   * @param {string} shipSymbol The ship symbol.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public createShipShipScan(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .createShipShipScan(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Scan for nearby systems, retrieving information on the systems\' distance from the ship and their waypoints. Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
   * @summary Scan Systems
   * @param {string} shipSymbol The ship symbol.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public createShipSystemScan(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .createShipSystemScan(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Scan for nearby waypoints, retrieving detailed information on each waypoint in range. Scanning uncharted waypoints will allow you to ignore their uncharted state and will list the waypoints\' traits.  Requires a ship to have the `Sensor Array` mount installed to use.  The ship will enter a cooldown after using this function, during which it cannot execute certain actions.
   * @summary Scan Waypoints
   * @param {string} shipSymbol The ship symbol.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public createShipWaypointScan(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .createShipWaypointScan(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create surveys on a waypoint that can be extracted such as asteroid fields. A survey focuses on specific types of deposits from the extracted location. When ships extract using this survey, they are guaranteed to procure a high amount of one of the goods in the survey.  In order to use a survey, send the entire survey details in the body of the extract request.  Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.  Your ship will enter a cooldown after surveying in which it is unable to perform certain actions. Surveys will eventually expire after a period of time or will be exhausted after being extracted several times based on the survey\'s size. Multiple ships can use the same survey for extraction.  A ship must have the `Surveyor` mount installed in order to use this function.
   * @summary Create Survey
   * @param {string} shipSymbol The symbol of the ship.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public createSurvey(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .createSurvey(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Attempt to dock your ship at its current location. Docking will only succeed if your ship is capable of docking at the time of the request.  Docked ships can access elements in their current location, such as the market or a shipyard, but cannot do actions that require the ship to be above surface such as navigating or extracting.  The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
   * @summary Dock Ship
   * @param {string} shipSymbol The symbol of the ship.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public dockShip(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .dockShip(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Extract resources from a waypoint that can be extracted, such as asteroid fields, into your ship. Send an optional survey as the payload to target specific yields.  The ship must be in orbit to be able to extract and must have mining equipments installed that can extract goods, such as the `Gas Siphon` mount for gas-based goods or `Mining Laser` mount for ore-based goods.  The survey property is now deprecated. See the `extract/survey` endpoint for more details.
   * @summary Extract Resources
   * @param {string} shipSymbol The ship symbol.
   * @param {ExtractResourcesRequest} [extractResourcesRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public extractResources(shipSymbol: string, extractResourcesRequest?: ExtractResourcesRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .extractResources(shipSymbol, extractResourcesRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Use a survey when extracting resources from a waypoint. This endpoint requires a survey as the payload, which allows your ship to extract specific yields.  Send the full survey object as the payload which will be validated according to the signature. If the signature is invalid, or any properties of the survey are changed, the request will fail.
   * @summary Extract Resources with Survey
   * @param {string} shipSymbol The ship symbol.
   * @param {Survey} [survey]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public extractResourcesWithSurvey(shipSymbol: string, survey?: Survey, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .extractResourcesWithSurvey(shipSymbol, survey, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the mounts installed on a ship.
   * @summary Get Mounts
   * @param {string} shipSymbol The ship\&#39;s symbol.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public getMounts(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .getMounts(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the details of a ship under your agent\'s ownership.
   * @summary Get Ship
   * @param {string} shipSymbol The symbol of the ship.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public getMyShip(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .getMyShip(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the cargo of a ship under your agent\'s ownership.
   * @summary Get Ship Cargo
   * @param {string} shipSymbol The symbol of the ship.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public getMyShipCargo(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .getMyShipCargo(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return a paginated list of all of ships under your agent\'s ownership.
   * @summary List Ships
   * @param {number} [page] What entry offset to request
   * @param {number} [limit] How many entries to return per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public getMyShips(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .getMyShips(page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve the details of your ship\'s reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.  Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.  Response returns a 204 status code (no-content) when the ship has no cooldown.
   * @summary Get Ship Cooldown
   * @param {string} shipSymbol The symbol of the ship.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public getShipCooldown(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .getShipCooldown(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the current nav status of a ship.
   * @summary Get Ship Nav
   * @param {string} shipSymbol The ship symbol.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public getShipNav(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .getShipNav(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Install a mount on a ship.  In order to install a mount, the ship must be docked and located in a waypoint that has a `Shipyard` trait. The ship also must have the mount to install in its cargo hold.  An installation fee will be deduced by the Shipyard for installing the mount on the ship.
   * @summary Install Mount
   * @param {string} shipSymbol The ship\&#39;s symbol.
   * @param {InstallMountRequest} [installMountRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public installMount(shipSymbol: string, installMountRequest?: InstallMountRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .installMount(shipSymbol, installMountRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Jettison cargo from your ship\'s cargo hold.
   * @summary Jettison Cargo
   * @param {string} shipSymbol The ship symbol.
   * @param {JettisonRequest} [jettisonRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public jettison(shipSymbol: string, jettisonRequest?: JettisonRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .jettison(shipSymbol, jettisonRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Jump your ship instantly to a target connected waypoint. The ship must be in orbit to execute a jump.  A unit of antimatter is purchased and consumed from the market when jumping. The price of antimatter is determined by the market and is subject to change. A ship can only jump to connected waypoints
   * @summary Jump Ship
   * @param {string} shipSymbol The ship symbol.
   * @param {JumpShipRequest} [jumpShipRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public jumpShip(shipSymbol: string, jumpShipRequest?: JumpShipRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .jumpShip(shipSymbol, jumpShipRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Navigate to a target destination. The ship must be in orbit to use this function. The destination waypoint must be within the same system as the ship\'s current location. Navigating will consume the necessary fuel from the ship\'s manifest based on the distance to the target waypoint.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it\'s destination.  To travel between systems, see the ship\'s Warp or Jump actions.
   * @summary Navigate Ship
   * @param {string} shipSymbol The ship symbol.
   * @param {NavigateShipRequest} [navigateShipRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public navigateShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .navigateShip(shipSymbol, navigateShipRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Negotiate a new contract with the HQ.  In order to negotiate a new contract, an agent must not have ongoing or offered contracts over the allowed maximum amount. Currently the maximum contracts an agent can have at a time is 1.  Once a contract is negotiated, it is added to the list of contracts offered to the agent, which the agent can then accept.   The ship must be present at any waypoint with a faction present to negotiate a contract with that faction.
   * @summary Negotiate Contract
   * @param {string} shipSymbol The ship\&#39;s symbol.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public negotiateContract(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .negotiateContract(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Attempt to move your ship into orbit at its current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.  Orbiting ships are able to do actions that require the ship to be above surface such as navigating or extracting, but cannot access elements in their current waypoint, such as the market or a shipyard.  The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
   * @summary Orbit Ship
   * @param {string} shipSymbol The symbol of the ship.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public orbitShip(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .orbitShip(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update the nav configuration of a ship.  Currently only supports configuring the Flight Mode of the ship, which affects its speed and fuel consumption.
   * @summary Patch Ship Nav
   * @param {string} shipSymbol The ship symbol.
   * @param {PatchShipNavRequest} [patchShipNavRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public patchShipNav(shipSymbol: string, patchShipNavRequest?: PatchShipNavRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .patchShipNav(shipSymbol, patchShipNavRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Purchase cargo from a market.  The ship must be docked in a waypoint that has `Marketplace` trait, and the market must be selling a good to be able to purchase it.  The maximum amount of units of a good that can be purchased in each transaction are denoted by the `tradeVolume` value of the good, which can be viewed by using the Get Market action.  Purchased goods are added to the ship\'s cargo hold.
   * @summary Purchase Cargo
   * @param {string} shipSymbol The ship\&#39;s symbol.
   * @param {PurchaseCargoRequest} [purchaseCargoRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public purchaseCargo(shipSymbol: string, purchaseCargoRequest?: PurchaseCargoRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .purchaseCargo(shipSymbol, purchaseCargoRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Purchase a ship from a Shipyard. In order to use this function, a ship under your agent\'s ownership must be in a waypoint that has the `Shipyard` trait, and the Shipyard must sell the type of the desired ship.  Shipyards typically offer ship types, which are predefined templates of ships that have dedicated roles. A template comes with a preset of an engine, a reactor, and a frame. It may also include a few modules and mounts.
   * @summary Purchase Ship
   * @param {PurchaseShipRequest} [purchaseShipRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public purchaseShip(purchaseShipRequest?: PurchaseShipRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .purchaseShip(purchaseShipRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Refuel your ship by buying fuel from the local market.  Requires the ship to be docked in a waypoint that has the `Marketplace` trait, and the market must be selling fuel in order to refuel.  Each fuel bought from the market replenishes 100 units in your ship\'s fuel.  Ships will always be refuel to their frame\'s maximum fuel capacity when using this action.
   * @summary Refuel Ship
   * @param {string} shipSymbol The ship symbol.
   * @param {RefuelShipRequest} [refuelShipRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public refuelShip(shipSymbol: string, refuelShipRequest?: RefuelShipRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .refuelShip(shipSymbol, refuelShipRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Remove a mount from a ship.  The ship must be docked in a waypoint that has the `Shipyard` trait, and must have the desired mount that it wish to remove installed.  A removal fee will be deduced from the agent by the Shipyard.
   * @summary Remove Mount
   * @param {string} shipSymbol The ship\&#39;s symbol.
   * @param {RemoveMountRequest} [removeMountRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public removeMount(shipSymbol: string, removeMountRequest?: RemoveMountRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .removeMount(shipSymbol, removeMountRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Sell cargo in your ship to a market that trades this cargo. The ship must be docked in a waypoint that has the `Marketplace` trait in order to use this function.
   * @summary Sell Cargo
   * @param {string} shipSymbol Symbol of a ship.
   * @param {SellCargoRequest} [sellCargoRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public sellCargo(shipSymbol: string, sellCargoRequest?: SellCargoRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .sellCargo(shipSymbol, sellCargoRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request. In order to be able to refine, a ship must have goods that can be refined and have installed a `Refinery` module that can refine it.  When refining, 30 basic goods will be converted into 10 processed goods.
   * @summary Ship Refine
   * @param {string} shipSymbol The symbol of the ship.
   * @param {ShipRefineRequest} [shipRefineRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public shipRefine(shipSymbol: string, shipRefineRequest?: ShipRefineRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .shipRefine(shipSymbol, shipRefineRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Siphon gases, such as hydrocarbon, from gas giants.  The ship must be in orbit to be able to siphon and must have siphon mounts and a gas processor installed.
   * @summary Siphon Resources
   * @param {string} shipSymbol The ship symbol.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public siphonResources(shipSymbol: string, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .siphonResources(shipSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Transfer cargo between ships.  The receiving ship must be in the same waypoint as the transferring ship, and it must able to hold the additional cargo after the transfer is complete. Both ships also must be in the same state, either both are docked or both are orbiting.  The response body\'s cargo shows the cargo of the transferring ship after the transfer is complete.
   * @summary Transfer Cargo
   * @param {string} shipSymbol The transferring ship\&#39;s symbol.
   * @param {TransferCargoRequest} [transferCargoRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public transferCargo(shipSymbol: string, transferCargoRequest?: TransferCargoRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .transferCargo(shipSymbol, transferCargoRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Warp your ship to a target destination in another system. The ship must be in orbit to use this function and must have the `Warp Drive` module installed. Warping will consume the necessary fuel from the ship\'s manifest.  The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at its destination.
   * @summary Warp Ship
   * @param {string} shipSymbol The ship symbol.
   * @param {NavigateShipRequest} [navigateShipRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FleetApi
   */
  public warpShip(shipSymbol: string, navigateShipRequest?: NavigateShipRequest, options?: RawAxiosRequestConfig) {
    return FleetApiFp(this.configuration)
      .warpShip(shipSymbol, navigateShipRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get construction details for a waypoint. Requires a waypoint with a property of `isUnderConstruction` to be true.
     * @summary Get Construction Site
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConstruction: async (systemSymbol: string, waypointSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'systemSymbol' is not null or undefined
      assertParamExists('getConstruction', 'systemSymbol', systemSymbol)
      // verify required parameter 'waypointSymbol' is not null or undefined
      assertParamExists('getConstruction', 'waypointSymbol', waypointSymbol)
      const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}/construction`
        .replace(`{${'systemSymbol'}}`, encodeURIComponent(String(systemSymbol)))
        .replace(`{${'waypointSymbol'}}`, encodeURIComponent(String(waypointSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get jump gate details for a waypoint. Requires a waypoint of type `JUMP_GATE` to use.  Waypoints connected to this jump gate can be
     * @summary Get Jump Gate
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJumpGate: async (systemSymbol: string, waypointSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'systemSymbol' is not null or undefined
      assertParamExists('getJumpGate', 'systemSymbol', systemSymbol)
      // verify required parameter 'waypointSymbol' is not null or undefined
      assertParamExists('getJumpGate', 'waypointSymbol', waypointSymbol)
      const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}/jump-gate`
        .replace(`{${'systemSymbol'}}`, encodeURIComponent(String(systemSymbol)))
        .replace(`{${'waypointSymbol'}}`, encodeURIComponent(String(waypointSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve imports, exports and exchange data from a marketplace. Requires a waypoint that has the `Marketplace` trait to use.  Send a ship to the waypoint to access trade good prices and recent transactions. Refer to the [Market Overview page](https://docs.spacetraders.io/game-concepts/markets) to gain better a understanding of the market in the game.
     * @summary Get Market
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarket: async (systemSymbol: string, waypointSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'systemSymbol' is not null or undefined
      assertParamExists('getMarket', 'systemSymbol', systemSymbol)
      // verify required parameter 'waypointSymbol' is not null or undefined
      assertParamExists('getMarket', 'waypointSymbol', waypointSymbol)
      const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}/market`
        .replace(`{${'systemSymbol'}}`, encodeURIComponent(String(systemSymbol)))
        .replace(`{${'waypointSymbol'}}`, encodeURIComponent(String(waypointSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the shipyard for a waypoint. Requires a waypoint that has the `Shipyard` trait to use. Send a ship to the waypoint to access data on ships that are currently available for purchase and recent transactions.
     * @summary Get Shipyard
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShipyard: async (systemSymbol: string, waypointSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'systemSymbol' is not null or undefined
      assertParamExists('getShipyard', 'systemSymbol', systemSymbol)
      // verify required parameter 'waypointSymbol' is not null or undefined
      assertParamExists('getShipyard', 'waypointSymbol', waypointSymbol)
      const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}/shipyard`
        .replace(`{${'systemSymbol'}}`, encodeURIComponent(String(systemSymbol)))
        .replace(`{${'waypointSymbol'}}`, encodeURIComponent(String(waypointSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the details of a system.
     * @summary Get System
     * @param {string} systemSymbol The system symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystem: async (systemSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'systemSymbol' is not null or undefined
      assertParamExists('getSystem', 'systemSymbol', systemSymbol)
      const localVarPath = `/systems/{systemSymbol}`.replace(`{${'systemSymbol'}}`, encodeURIComponent(String(systemSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return a paginated list of all of the waypoints for a given system.  If a waypoint is uncharted, it will return the `Uncharted` trait instead of its actual traits.
     * @summary List Waypoints in System
     * @param {string} systemSymbol The system symbol
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {WaypointType} [type] Filter waypoints by type.
     * @param {GetSystemWaypointsTraitsParameter} [traits] Filter waypoints by one or more traits.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemWaypoints: async (
      systemSymbol: string,
      page?: number,
      limit?: number,
      type?: WaypointType,
      traits?: GetSystemWaypointsTraitsParameter,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'systemSymbol' is not null or undefined
      assertParamExists('getSystemWaypoints', 'systemSymbol', systemSymbol)
      const localVarPath = `/systems/{systemSymbol}/waypoints`.replace(`{${'systemSymbol'}}`, encodeURIComponent(String(systemSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      if (traits !== undefined) {
        for (const [key, value] of Object.entries(traits)) {
          localVarQueryParameter[key] = value
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return a paginated list of all systems.
     * @summary List Systems
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystems: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/systems`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * View the details of a waypoint.  If the waypoint is uncharted, it will return the \'Uncharted\' trait instead of its actual traits.
     * @summary Get Waypoint
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWaypoint: async (systemSymbol: string, waypointSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'systemSymbol' is not null or undefined
      assertParamExists('getWaypoint', 'systemSymbol', systemSymbol)
      // verify required parameter 'waypointSymbol' is not null or undefined
      assertParamExists('getWaypoint', 'waypointSymbol', waypointSymbol)
      const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}`
        .replace(`{${'systemSymbol'}}`, encodeURIComponent(String(systemSymbol)))
        .replace(`{${'waypointSymbol'}}`, encodeURIComponent(String(waypointSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Supply a construction site with the specified good. Requires a waypoint with a property of `isUnderConstruction` to be true.  The good must be in your ship\'s cargo. The good will be removed from your ship\'s cargo and added to the construction site\'s materials.
     * @summary Supply Construction Site
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {SupplyConstructionRequest} [supplyConstructionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supplyConstruction: async (
      systemSymbol: string,
      waypointSymbol: string,
      supplyConstructionRequest?: SupplyConstructionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'systemSymbol' is not null or undefined
      assertParamExists('supplyConstruction', 'systemSymbol', systemSymbol)
      // verify required parameter 'waypointSymbol' is not null or undefined
      assertParamExists('supplyConstruction', 'waypointSymbol', waypointSymbol)
      const localVarPath = `/systems/{systemSymbol}/waypoints/{waypointSymbol}/construction/supply`
        .replace(`{${'systemSymbol'}}`, encodeURIComponent(String(systemSymbol)))
        .replace(`{${'waypointSymbol'}}`, encodeURIComponent(String(waypointSymbol)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AgentToken required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(supplyConstructionRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
  return {
    /**
     * Get construction details for a waypoint. Requires a waypoint with a property of `isUnderConstruction` to be true.
     * @summary Get Construction Site
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConstruction(
      systemSymbol: string,
      waypointSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConstruction200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConstruction(systemSymbol, waypointSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['SystemsApi.getConstruction']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get jump gate details for a waypoint. Requires a waypoint of type `JUMP_GATE` to use.  Waypoints connected to this jump gate can be
     * @summary Get Jump Gate
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJumpGate(
      systemSymbol: string,
      waypointSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJumpGate200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getJumpGate(systemSymbol, waypointSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['SystemsApi.getJumpGate']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieve imports, exports and exchange data from a marketplace. Requires a waypoint that has the `Marketplace` trait to use.  Send a ship to the waypoint to access trade good prices and recent transactions. Refer to the [Market Overview page](https://docs.spacetraders.io/game-concepts/markets) to gain better a understanding of the market in the game.
     * @summary Get Market
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMarket(
      systemSymbol: string,
      waypointSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarket200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMarket(systemSymbol, waypointSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['SystemsApi.getMarket']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get the shipyard for a waypoint. Requires a waypoint that has the `Shipyard` trait to use. Send a ship to the waypoint to access data on ships that are currently available for purchase and recent transactions.
     * @summary Get Shipyard
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShipyard(
      systemSymbol: string,
      waypointSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShipyard200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShipyard(systemSymbol, waypointSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['SystemsApi.getShipyard']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get the details of a system.
     * @summary Get System
     * @param {string} systemSymbol The system symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystem(
      systemSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystem200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystem(systemSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['SystemsApi.getSystem']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return a paginated list of all of the waypoints for a given system.  If a waypoint is uncharted, it will return the `Uncharted` trait instead of its actual traits.
     * @summary List Waypoints in System
     * @param {string} systemSymbol The system symbol
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {WaypointType} [type] Filter waypoints by type.
     * @param {GetSystemWaypointsTraitsParameter} [traits] Filter waypoints by one or more traits.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemWaypoints(
      systemSymbol: string,
      page?: number,
      limit?: number,
      type?: WaypointType,
      traits?: GetSystemWaypointsTraitsParameter,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystemWaypoints200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemWaypoints(systemSymbol, page, limit, type, traits, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['SystemsApi.getSystemWaypoints']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return a paginated list of all systems.
     * @summary List Systems
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystems(
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystems200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystems(page, limit, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['SystemsApi.getSystems']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * View the details of a waypoint.  If the waypoint is uncharted, it will return the \'Uncharted\' trait instead of its actual traits.
     * @summary Get Waypoint
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWaypoint(
      systemSymbol: string,
      waypointSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWaypoint200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWaypoint(systemSymbol, waypointSymbol, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['SystemsApi.getWaypoint']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Supply a construction site with the specified good. Requires a waypoint with a property of `isUnderConstruction` to be true.  The good must be in your ship\'s cargo. The good will be removed from your ship\'s cargo and added to the construction site\'s materials.
     * @summary Supply Construction Site
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {SupplyConstructionRequest} [supplyConstructionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async supplyConstruction(
      systemSymbol: string,
      waypointSymbol: string,
      supplyConstructionRequest?: SupplyConstructionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplyConstruction201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.supplyConstruction(
        systemSymbol,
        waypointSymbol,
        supplyConstructionRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath = operationServerMap['SystemsApi.supplyConstruction']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SystemsApiFp(configuration)
  return {
    /**
     * Get construction details for a waypoint. Requires a waypoint with a property of `isUnderConstruction` to be true.
     * @summary Get Construction Site
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConstruction(systemSymbol: string, waypointSymbol: string, options?: any): AxiosPromise<GetConstruction200Response> {
      return localVarFp.getConstruction(systemSymbol, waypointSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Get jump gate details for a waypoint. Requires a waypoint of type `JUMP_GATE` to use.  Waypoints connected to this jump gate can be
     * @summary Get Jump Gate
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJumpGate(systemSymbol: string, waypointSymbol: string, options?: any): AxiosPromise<GetJumpGate200Response> {
      return localVarFp.getJumpGate(systemSymbol, waypointSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Retrieve imports, exports and exchange data from a marketplace. Requires a waypoint that has the `Marketplace` trait to use.  Send a ship to the waypoint to access trade good prices and recent transactions. Refer to the [Market Overview page](https://docs.spacetraders.io/game-concepts/markets) to gain better a understanding of the market in the game.
     * @summary Get Market
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarket(systemSymbol: string, waypointSymbol: string, options?: any): AxiosPromise<GetMarket200Response> {
      return localVarFp.getMarket(systemSymbol, waypointSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the shipyard for a waypoint. Requires a waypoint that has the `Shipyard` trait to use. Send a ship to the waypoint to access data on ships that are currently available for purchase and recent transactions.
     * @summary Get Shipyard
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShipyard(systemSymbol: string, waypointSymbol: string, options?: any): AxiosPromise<GetShipyard200Response> {
      return localVarFp.getShipyard(systemSymbol, waypointSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Get the details of a system.
     * @summary Get System
     * @param {string} systemSymbol The system symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystem(systemSymbol: string, options?: any): AxiosPromise<GetSystem200Response> {
      return localVarFp.getSystem(systemSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Return a paginated list of all of the waypoints for a given system.  If a waypoint is uncharted, it will return the `Uncharted` trait instead of its actual traits.
     * @summary List Waypoints in System
     * @param {string} systemSymbol The system symbol
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {WaypointType} [type] Filter waypoints by type.
     * @param {GetSystemWaypointsTraitsParameter} [traits] Filter waypoints by one or more traits.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemWaypoints(
      systemSymbol: string,
      page?: number,
      limit?: number,
      type?: WaypointType,
      traits?: GetSystemWaypointsTraitsParameter,
      options?: any,
    ): AxiosPromise<GetSystemWaypoints200Response> {
      return localVarFp.getSystemWaypoints(systemSymbol, page, limit, type, traits, options).then((request) => request(axios, basePath))
    },
    /**
     * Return a paginated list of all systems.
     * @summary List Systems
     * @param {number} [page] What entry offset to request
     * @param {number} [limit] How many entries to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystems(page?: number, limit?: number, options?: any): AxiosPromise<GetSystems200Response> {
      return localVarFp.getSystems(page, limit, options).then((request) => request(axios, basePath))
    },
    /**
     * View the details of a waypoint.  If the waypoint is uncharted, it will return the \'Uncharted\' trait instead of its actual traits.
     * @summary Get Waypoint
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWaypoint(systemSymbol: string, waypointSymbol: string, options?: any): AxiosPromise<GetWaypoint200Response> {
      return localVarFp.getWaypoint(systemSymbol, waypointSymbol, options).then((request) => request(axios, basePath))
    },
    /**
     * Supply a construction site with the specified good. Requires a waypoint with a property of `isUnderConstruction` to be true.  The good must be in your ship\'s cargo. The good will be removed from your ship\'s cargo and added to the construction site\'s materials.
     * @summary Supply Construction Site
     * @param {string} systemSymbol The system symbol
     * @param {string} waypointSymbol The waypoint symbol
     * @param {SupplyConstructionRequest} [supplyConstructionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supplyConstruction(
      systemSymbol: string,
      waypointSymbol: string,
      supplyConstructionRequest?: SupplyConstructionRequest,
      options?: any,
    ): AxiosPromise<SupplyConstruction201Response> {
      return localVarFp
        .supplyConstruction(systemSymbol, waypointSymbol, supplyConstructionRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
  /**
   * Get construction details for a waypoint. Requires a waypoint with a property of `isUnderConstruction` to be true.
   * @summary Get Construction Site
   * @param {string} systemSymbol The system symbol
   * @param {string} waypointSymbol The waypoint symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public getConstruction(systemSymbol: string, waypointSymbol: string, options?: RawAxiosRequestConfig) {
    return SystemsApiFp(this.configuration)
      .getConstruction(systemSymbol, waypointSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get jump gate details for a waypoint. Requires a waypoint of type `JUMP_GATE` to use.  Waypoints connected to this jump gate can be
   * @summary Get Jump Gate
   * @param {string} systemSymbol The system symbol
   * @param {string} waypointSymbol The waypoint symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public getJumpGate(systemSymbol: string, waypointSymbol: string, options?: RawAxiosRequestConfig) {
    return SystemsApiFp(this.configuration)
      .getJumpGate(systemSymbol, waypointSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieve imports, exports and exchange data from a marketplace. Requires a waypoint that has the `Marketplace` trait to use.  Send a ship to the waypoint to access trade good prices and recent transactions. Refer to the [Market Overview page](https://docs.spacetraders.io/game-concepts/markets) to gain better a understanding of the market in the game.
   * @summary Get Market
   * @param {string} systemSymbol The system symbol
   * @param {string} waypointSymbol The waypoint symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public getMarket(systemSymbol: string, waypointSymbol: string, options?: RawAxiosRequestConfig) {
    return SystemsApiFp(this.configuration)
      .getMarket(systemSymbol, waypointSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the shipyard for a waypoint. Requires a waypoint that has the `Shipyard` trait to use. Send a ship to the waypoint to access data on ships that are currently available for purchase and recent transactions.
   * @summary Get Shipyard
   * @param {string} systemSymbol The system symbol
   * @param {string} waypointSymbol The waypoint symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public getShipyard(systemSymbol: string, waypointSymbol: string, options?: RawAxiosRequestConfig) {
    return SystemsApiFp(this.configuration)
      .getShipyard(systemSymbol, waypointSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get the details of a system.
   * @summary Get System
   * @param {string} systemSymbol The system symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public getSystem(systemSymbol: string, options?: RawAxiosRequestConfig) {
    return SystemsApiFp(this.configuration)
      .getSystem(systemSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return a paginated list of all of the waypoints for a given system.  If a waypoint is uncharted, it will return the `Uncharted` trait instead of its actual traits.
   * @summary List Waypoints in System
   * @param {string} systemSymbol The system symbol
   * @param {number} [page] What entry offset to request
   * @param {number} [limit] How many entries to return per page
   * @param {WaypointType} [type] Filter waypoints by type.
   * @param {GetSystemWaypointsTraitsParameter} [traits] Filter waypoints by one or more traits.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public getSystemWaypoints(
    systemSymbol: string,
    page?: number,
    limit?: number,
    type?: WaypointType,
    traits?: GetSystemWaypointsTraitsParameter,
    options?: RawAxiosRequestConfig,
  ) {
    return SystemsApiFp(this.configuration)
      .getSystemWaypoints(systemSymbol, page, limit, type, traits, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return a paginated list of all systems.
   * @summary List Systems
   * @param {number} [page] What entry offset to request
   * @param {number} [limit] How many entries to return per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public getSystems(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
    return SystemsApiFp(this.configuration)
      .getSystems(page, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * View the details of a waypoint.  If the waypoint is uncharted, it will return the \'Uncharted\' trait instead of its actual traits.
   * @summary Get Waypoint
   * @param {string} systemSymbol The system symbol
   * @param {string} waypointSymbol The waypoint symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public getWaypoint(systemSymbol: string, waypointSymbol: string, options?: RawAxiosRequestConfig) {
    return SystemsApiFp(this.configuration)
      .getWaypoint(systemSymbol, waypointSymbol, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Supply a construction site with the specified good. Requires a waypoint with a property of `isUnderConstruction` to be true.  The good must be in your ship\'s cargo. The good will be removed from your ship\'s cargo and added to the construction site\'s materials.
   * @summary Supply Construction Site
   * @param {string} systemSymbol The system symbol
   * @param {string} waypointSymbol The waypoint symbol
   * @param {SupplyConstructionRequest} [supplyConstructionRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemsApi
   */
  public supplyConstruction(
    systemSymbol: string,
    waypointSymbol: string,
    supplyConstructionRequest?: SupplyConstructionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SystemsApiFp(this.configuration)
      .supplyConstruction(systemSymbol, waypointSymbol, supplyConstructionRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
